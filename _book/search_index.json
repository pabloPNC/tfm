[["introducción.html", "Evaluación de métricas para la búsqueda de biomarcadores de diagnóstico y pronóstico clínico Introducción Conjuntos de datos Software utilizado Estructura", " Evaluación de métricas para la búsqueda de biomarcadores de diagnóstico y pronóstico clínico Pablo Navarro Introducción Los avances en tecnologías de alto rendimiento están permitiendo la identificación simultánea de un gran número de biomarcadores para ayudar en la toma de decisiones de procesos relevantes. Las curvas de características operativas de receptor (\\(ROC\\)), y especialmente el área bajo las curvas \\(ROC\\) (\\(AUC\\)), son herramientas útiles para evaluar y comparar el rendimiento de estos biomarcadores en aplicaciones biomédicas y bioinformáticas. Con estas herramientas, es posible describir la utilidad del biomarcador para evaluar procesos discriminatorios, e.g. detección de enfermedades a través de biomarcadores, selección de genes diferencialmente expresados en experimentos de microarrays, etcétera. Es más, actualmente se han desarrollado diversos paquetes de software estadístico que facilitan el análisis utilizando estas curvas \\(ROC\\). Sin embargo, cuando una tarea requiere de una determinada precisión, el \\(AUC\\) total no es un índice significativo del rendimiento del biomarcador. Así, nuevas herramientas analíticas han sido propuestas y ampliamente utilizadas en investigación bajo rangos preestablecidos de especificidad y sensibilidad. Sin embargo, hasta ahora, estos métodos han presentado diversas limitaciones, entre ellas, no han sido sensibles al comparar curvas \\(ROC\\) de biomarcadores que se cruzan, siendo esto un indicativo de su baja capacidad de discriminación. De este modo, el objetivo de este trabajo es estudiar diversos índices de áreas parciales los cuales permiten comparar porciones de estas curvas \\(ROC\\), así como su utilidad en aplicaciones biomédicas y bioinformáticas. Conjuntos de datos En la evaluación de los distintos índices se utilizarán muestras de pacientes con cáncer de próstata (PCa), puesto que esta enfermedad presenta un escenario dónde estudiar regiones de las curvas \\(ROC\\) es necesario. Resultados de experimentos de single cell RNA sequencing (scRNA-seq) se utilizarán para la selección de biomarcadores relevantes en la enfermedad. Seleccionados los biomarcadores, sus niveles de expresión se contrastarán con muestras de pacientes enfermos en experimentos bulk RNA sequencing (RNA-seq). Los datos del experimento de scRNA-seq provienen de muestras de 2 pacientes diagnosticados con PCa. Este diagnóstico fue realizado a través de observaciones morfológicas (puntuaciones de Gleason de 6 y 7) y ante la presencia de marcadores de la enfermedad, AMACR y TP63. Los conjuntos de datos en crudo y procesados se encuentran disponibles en Gene Expression Omnibus (GEO) bajo el identificador GSE157703. Los conjuntos de datos utilizados para contrastar los biomarcadores fueron extraídos de The Cancer Genome Atlas (TCGA), considerando aquellos provenientes de tejidos de próstata y experimentos de RNA-seq1. Software utilizado En la siguiente sección se indican las librerías utilizadas, así como una pequeña descripción indicando el motivo de su uso. Información más detallada de la sesión utilizada durante el trabajo se puede encontrar en el Apéndice A. Librerías externas Las librerías externas utilizadas se pueden agrupar según su uso dado durante el análisis: Lectura de archivos: readr. Lectura de archivos de propósito general (Wickham, Hester, and Bryan 2024). data.table. Lecturas de archivos de gran tamaño, en concreto archivos de experimentos de scRNA-seq (Barrett et al. 2024). Manipulación de tablas de datos: tibble. Creación de objetos tibble, análogos de data.frame pero más estrictos, evitar posibles errores durante su manipulación (Müller and Wickham 2023). dplyr. Selección, filtrado, ordenación, creación etc. de filas y columnas en conjuntos de datos (Wickham et al. 2023). tidyr. Organización del conjunto de datos en filas y columnas. Utilizado para transformar genes y/o muestras en filas y columnas en el conjunto de datos según sea necesario (Wickham, Vaughan, and Girlich 2024). Análisis de scRNA-seq: Seurat. Librería que provee herramientas para trabajar con matrices de cuentas en experimentos de scRNA-seq, además de procesar y analizar los datos (Satija 2024). Análisis de \\(AUC\\): pROC. Librería que permite el cálculo de \\(AUC\\)s y \\(pAUC\\)s. Además también permite calcular el \\(SpAUC\\), una transformación del \\(pAUC\\) que se tratará más adelante (Robin et al. 2023). ROCpAI. Librería de Bioconductor que permite analizar curvas \\(ROC\\) en regiones de alta especificidad además de calcular el \\(TpAUC\\), otra transformación del \\(pAUC\\) que también se tratará (Garcia, Franco, and Vivo 2024). Misceláneo: stringr. Librería para trabajar de forma más sencilla con strings (Wickham 2023b). purrr. Librería que provee herramientas de programación funcional (Wickham and Henry 2023). forcats. Librería que provee herramientas para trabajar con objetos de tipo factor (Wickham 2023a). biomaRt. Librería que provee una interfaz para conectar a las bases de datos de BioMart, utilizada para encontrar genes por sus identificadores y viceversa (Durinck and Huber 2024). Librerías propias Además de las librerías externas mencionadas, para facilitar el análisis de índices derivados de áreas parciales, se ha desarrollado la librería ROCnGO. Esta librería además de proveer herramientas para el cálculo de los índices anteriormente comentados, también permite aplicar estos cálculos al conjunto de datos entero automatizando en gran medida la tarea. La librería también incluye otros dos índices adicionales, el \\(NpAUC\\) y el \\(FpAUC\\), que también se tratarán más adelante. Finalmente, esta también incluye herramientas para graficar este tipo de curvas y las regiones en las que se encuentran comprendidas utilizando una sintaxis sencilla, lo que facilita la comparación de los biomarcadores de estudio. Actualmente la librería se puede obtener a través de su repositorio de GitHub utilizando la siguiente función. devtools::install_github(repo = &quot;pabloPNC/ROCnGO&quot;) Estructura La primera parte del trabajo se centrará en encontrar biomarcadores expresados específicamente en células cancerosas. En la Sección 1, utilizando los datos de experimentos de scRNA-seq, se identificarán las células del tejido que se corresponden con células luminales de próstata, las precursoras de la enfermedad. En la Sección 2 se identificarán las células malignas entre las seleccionadas previamente así como los genes que expresan. En la segunda parte del trabajo se generará el conjunto de datos sobre el que se analizarán los distintos biomarcadores. En la Sección 3 se procesarán los datos del TCGA para generar una matriz de conteo que incluirá los genes expresados en diversas muestras de tejido. En la Sección 4 se filtrará esta matriz para seleccionar los genes indentificados en la primera parte, de esta forma se obtendrá una matriz que solamente contendrá biomarcadores relevantes para la enfermedad, eliminando ruido en el proceso. Finalmente en la tercera parte del trabajo (Sección 5), se calcularán y analizarán los distintos índices para los biomarcadores seleccionados en regiones de alta sensibilidad y especificidad de la curva. En la sección, también se expondrán las limitaciones de estos índices, para finalmente evaluar su utilidad como métrica considerando biomarcadores que actualmente son utilizados en el ámbito clínico. Además de los criterios indicados, solo se consideraron los datos depositados previamente a la última fecha de consulta (11/06/24).↩︎ "],["luminal-cells-selection.html", "1 Selección de células luminales de prostata 1.1 Importar matrices de cuentas 1.2 Preprocesamiento y CQ 1.3 Búsqueda de genes de alta variabilidad 1.4 Escalado de los datos 1.5 Reducción de la dimensionalidad 1.6 Integración de datos 1.7 Dimensionalidad del conjunto de datos 1.8 Agrupamiento de células 1.9 Reducción de la dimensionalidad no lineal (UMAP) 1.10 Búsqueda de genes expresados diferencialmente (DEG) 1.11 Selección de células", " 1 Selección de células luminales de prostata En esta sección se identificarán y seleccionarán células luminales de próstata, precursoras de la enfermedad, que posteriormente se usarán para identificar biomarcadores de la enfermedad. Para ello se utilizarán los datos de experimentos de scRNA-seq obtenidos de muestras de pacientes con la enfermedad (X. Ma et al. 2020). 1.1 Importar matrices de cuentas El primer paso será importar los datos, es decir las matrices de cuentas de cada paciente. Para facilitar este paso se define la función import_gene_counts que realizará los siguientes pasos: Usará la función data.table::fread, que permite una lectura rápida de archivos de gran tamaño. Asignará a las filas el nombre de las variables (genes) con la función rownames, los cuales se encontraban almacenados en la primera columna. Finalmente con la función dplyr::select se eliminará la primera columna con los nombres. En este caso se trabaja con dos conjuntos de datos provenientes de dos pacientes distintos, por lo que la función se aplicará para cada uno de ellos. import_gene_counts &lt;- function(file, data_table = FALSE) { count_matrix &lt;- data.table::fread(file, data.table = data_table) rownames(count_matrix) &lt;- count_matrix[[1]] count_matrix &lt;- select(count_matrix, -(1)) count_matrix } GSM4773522_PCa2_counts_matrix &lt;- import_gene_counts( &quot;./GSE157703_RAW/GSM4773522_PCa2_gene_counts_matrix.txt&quot;, data_table = FALSE ) GSM4773522_PCa1_counts_matrix &lt;- import_gene_counts( &quot;./GSE157703_RAW/GSM4773521_PCa1_gene_counts_matrix.txt&quot;, data_table = FALSE ) 1.2 Preprocesamiento y CQ Para realizar el análisis se utilizará el paquete Seurat, el cual proveerá las herramientas necesarias para llevar a cabo la selección de biomarcadores, así como de células de interés (Satija 2024). 1.2.1 Creación del objeto Seurat Antes de proceder al análisis de datos en experimentos de sc-RNAseq es recomendable realizar un control de calidad de las células. Con este proceso, es posible eliminar células de baja calidad que pueden generar ruido y malinterpretaciones de los datos, e.g. células rotas o muertas, multipletes, etc. La comunidad ha descrito diversas métricas para filtras estas células (Ilicic et al. 2016), pero de forma intuitiva podemos considerar las siguientes: Número de genes únicos expresados en cada célula: Las células de baja calidad presentan muy pocos genes únicos. Los multipletes presentan una aberrante alta cantidad de cuentas de genes. Número total de lecturas en una célula: Correlacionado con la cantidad de genes únicos. Porcentaje de lecturas mapeadas al genoma mitocondrial: Las células de baja calidad/muertas tienen una elevada contaminación mitocondrial. Seurat permite realizar este preprocesamiento durante la creación del objeto principal. En este caso, se filtrarán aquellos genes que se hayan expresado en menos de 3 células (min.cells = 3) y las células que hayan expresado menos de 200 genes distintos (min.features = 200). Estos valores se han decidido en función de los conjuntos de datos utilizados (X. Ma et al. 2020), para otros contextos otros valores pueden seleccionarse. La función para crear los objetos con los que se trabajará (CreateSeuratObject), utilizará las matrices de cuentas creadas en el apartado anterior y opcionalmente un identificador (project) que arbitrariamente utilizaremos para indicar el paciente del que provienen. seurat_object_1 &lt;- CreateSeuratObject( counts = GSM4773522_PCa1_counts_matrix, min.cells = 3, min.features = 200, project = &quot;Patient1&quot; ) seurat_object_2 &lt;- CreateSeuratObject( counts = GSM4773522_PCa2_counts_matrix, min.cells = 3, min.features = 200, project = &quot;Patient2&quot; ) Aunque para la creación de los objetos se parte de 2 conjuntos de datos distintos (uno por paciente), podemos fusionarlos en 1 solo, de forma que sea más sencillo trabajar con ellos. Esto es posible porque cada célula tiene asignada un identificador único que la diferencia del resto, además de indicar del paciente del que proviene. Para fusionar ambos objetos simplemente se utilizará la función merge. seurat_objects &lt;- merge(seurat_object_1, seurat_object_2) 1.2.2 Lecturas mapeadas al genoma mitocondrial Tras realizar un primer filtrado durante la creación de los objetos se debe realizar un segundo en función del porcentaje de lecturas mapeadas al genoma mitocondrial. Seurat no ofrece por defecto una forma de realizar este filtrado durante la creación del objeto, por lo que se realizará manualmente. En primer lugar, se creará una métrica con el porcentaje de lecturas mapeadas al genoma mitocondrial, para ello se utilizará la función PercentageFeatureSet. Esta función calcula para cada célula el porcentaje total de lecturas que pertenecen a un subgrupo concreto de genes. En el conjunto de datos, los genes pertenecientes al genoma mitocondrial están nombrados usando las iniciales “MT”, lo que se utilizará para indicar el subgrupo de genes con el argumento pattern. seurat_objects[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet( seurat_objects, pattern = &quot;^MT-&quot; ) Generada la métrica, se realizará el filtrado utilizando la función subset. Con ella, se seleccionará el subconjunto de los datos que cumpla con las condiciones especificadas, que para este caso, será de un porcentaje inferior a \\(0.4\\) (X. Ma et al. 2020). seurat_objects &lt;- subset( seurat_objects, subset = percent.mt &lt; 4 ) 1.2.3 Normalización Hasta este punto se ha trabajado con los datos en crudo, sin embargo para realizar análisis aguas abajo es conveniente trabajar con datos normalizados. Realizar una normalización de los datos nos permite que la heterogeneidad de los mismos se deba principalmente a diferencias biológicas y no a otros sesgos, que en su mayoría son técnicos e.g. diferencias en distintas células en la eficiencia en captura de cDNAs, ampliación por PCR etc. (Amezquita et al. 2024). Para realizar esta normalización, se utilizará la función la función Seurat::NormalizeData con el argumento normalization.method = \"LogNormalize\". Esta función aplicará un escalado global, es decir: en cada célula dividirá el número de cuentas de cada gen entre el número total de cuentas. Finalmente aplicará una trasformación logarítmica a los resultados. seurat_objects &lt;- NormalizeData( seurat_objects, normalization.method = &quot;LogNormalize&quot; ) 1.3 Búsqueda de genes de alta variabilidad Una vez realizado el preprocesamiento de los datos, se buscarán los genes que presentan una mayor variabilidad, es decir, que presenten niveles de expresión muy altos en algunas células y muy bajos en otras. La búsqueda de estos genes, y su uso en análisis aguas abajo, facilita la identificación de patrones de interés (Brennecke et al. 2013), por este motivo los usaremos en los siguientes pasos. Para seleccionar estos genes se usará la función Seurat::FindVariableFeatures, la cual requerirá, además del objeto seurat, un número de variables a seleccionar (nfeatures) que para este caso serán \\(2000\\). seurat_objects &lt;- FindVariableFeatures( seurat_objects, selection.method = &quot;vst&quot;, nfeatures = 2000 ) Las variables seleccionadas por la función pueden visualizarse utilizando Seurat::VariableFeaturePlot en función de su media y varianza. Para mayor claridad, los 10 primeros genes se mostrarán con su nombre en la figura 1.1. high_variable_genes &lt;- head(VariableFeatures(seurat_objects), 10) high_variable_genes_plot &lt;- VariableFeaturePlot(seurat_objects) LabelPoints( plot = high_variable_genes_plot, points = high_variable_genes, repel = TRUE ) Figura 1.1: Genes de alta variabilidad 1.4 Escalado de los datos En este tipo de experimentos, donde se trabaja con un gran número de variables, es habitual aplicar técnicas de reducción de la dimensionalidad. Sin embargo, previamente a este tipo de técnicas es conveniente aplicar un escalado y centrado de los datos. Esto se debe a que este tipo de técnicas son sensibles a conjuntos de datos donde las variables presentan escalas muy dispares. Realizando un escalado, genes que habitualmente se encuentren mucho más expresados de forma basal, no tendrán más peso en el análisis. Seurat provee la función ScaleData, que realizará este escalado además de un centrado de los datos. Por defecto la función hará que la expresión media para cada gen en todas las células sea \\(0\\) y su varianza igual a \\(1\\). Finalmente se indicará que los cálculos solo se realicen sobre los genes de alta variabilidad (features), dado que son los que se utilizarán posteriormente para el análisis. seurat_objects &lt;- ScaleData( seurat_objects, features = VariableFeatures(seurat_objects) ) 1.5 Reducción de la dimensionalidad Como se ha expresado previamente, el conjunto de datos tiene un alto número de variables y por tanto es conveniente aplicar técnicas de reducción de la dimensionalidad para trabajar con él. Por este motivo se realizará un análisis de componentes principales (PCA) sobre los datos ya escalados. Para aplicar esta técnica, Seurat provee la función RunPCA donde, de forma similar a la sección anterior, se especificarán los genes de mayor variabilidad (features), dado que serán estos con los que se desea trabajar. seurat_objects &lt;- RunPCA( seurat_objects, features = VariableFeatures(seurat_objects) ) 1.6 Integración de datos 1.6.1 Objetivos de la integración La integración de datos en scRNA-seq permite harmonizar conjuntos de datos dispares en una sola referencia (Stuart et al. 2019). Expresado de otra forma y aplicado a este caso, la integración permite encontrar correspondencias entre las células de ambos conjuntos de datos. De esta forma, es posible proyectar los resultados de un experimento en el espacio del otro, solventando diferencias que puedan deberse a utilizar datos de provenientes de pacientes distintos. Así, células del mismo tipo deberían agruparse juntas independientemente del individuo del que provengan. Indirectamente, la integración permite mejorar el poder estadístico en análisis posteriores, dado que permite utilizar varios conjuntos de datos simultáneamente. Además, aunque algunos de estos casos no se aplique para este trabajo, también habilita: Identificar subpoblaciones de células presentes en conjuntos de datos distintos. Comparar marcadores específicos de tipos celulares en diferentes condiciones (e.g. control vs tratamiento). 1.6.2 Integración Existen diversos métodos que se pueden utilizar para realizar la integración de datos, pero en este caso se usará el análisis de correlación canónica (CCA) (Stuart et al. 2019). Cuando se aplica este método, Seurat trabaja en un espacio de baja dimensionalidad, es decir usando las dimensiones generadas previamente en el PCA. A estas nuevas dimensiones se les aplica unas correcciones para generar unas nuevas que contemplan las fuentes de variación entre ambas muestras, de esta forma células del mismo tipo se agruparán posteriormente independientemente del paciente del que provengan. Para realizar esta integración se utilizará la función IntegrateLayers. En ella simplemente se indicará el nombre de la nueva reducción (new.reduction), la reducción a corregir (orig.reduction) y el método de integración a utilizar (method = CCAIntegration). seurat_objects &lt;- IntegrateLayers( seurat_objects, method = CCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.cca&quot; ) Realizada la integración, los conjuntos de datos del objeto pueden finalmente fusionarse para proseguir los análisis aguas abajo. Seurat realiza este paso internamente con la función JoinLayers. seurat_objects &lt;- JoinLayers(seurat_objects) 1.7 Dimensionalidad del conjunto de datos Como se ha expresado en la sección 1.5, los datos de experimentos de scRNA-seq presentan un gran número de variables y ruido. Por este motivo, trabajar con las variables de mayor variabilidad y aplicar técnicas para reducir el número de dimensiones, como el PCA, es recomendable. Las componentes producidas por esta técnica representan un conjunto de variables iniciales que están correlacionadas entre sí. Además, las variables de componentes distintas no están correlacionadas, por este motivo cada componente describe una cantidad de la variabilidad total del conjunto de datos. De esta forma, se plantea la cuestión de cuántas componentes se deben utilizar en análisis posteriores, o la “dimensionalidad” del conjunto de datos. Utilizar un gran número de componentes encapsula una mayor variabilidad de la total, sin embargo dificulta la tarea por el elevado número de variables. Por otra parte, trabajar con un menor número de dimensiones será más sencillo pero conservará una menor variabilidad, perdiendo información de esta forma. Para solventar este problema existen distintos métodos que ayudan a seleccionar la dimensionalidad de un conjunto de datos. Un método heurístico comúnmente utilizado es ‘el método del codo’, el cual implica representar gráficamente la variación explicada en función de su componente. Seurat provee la función ElbowPlot para aplicar este método. ElbowPlot(seurat_objects, ndims = 50) Figura 1.2: Método del codo. En ella se muestra varición explicada por una de las componentes principales Otra forma de visualizar esta variabilidad es a través de mapas de calor de las componentes principales. Seurat también permite automatizar este proceso a través de la función DimHeatmap. DimHeatmap( seurat_objects, dims = 1:21, cells = 500, balanced = TRUE ) Figura 1.3: Mapas de calor de las 21 primeras componentes Tras observar la figura 1.2 y 1.3, se puede observar que la variación empieza a disminuir a partir de la componente número 10. Sin embargo, se debe tener en cuenta que escoger menos componentes de lo ideal puede resultar en perdidas de información y propagación a los resultados finales. Por este motivo y de forma arbitraria, se seleccionará hasta la componente 20 donde el descenso de la variación explicada es más pronunciado, o en otras palabras, se está capturando la mayor parte de la variabilidad de los datos. 1.8 Agrupamiento de células Seleccionadas las dimensiones, el siguiente paso consistirá en agrupar las células del experimento. En primer lugar, se construirá un grafo con los K vecinos más cercanos (KNN) utilizando las dimensiones seleccionadas previamente. Para ello, se usará la función Seurat::FindNeighbors. seurat_objects &lt;- FindNeighbors( seurat_objects, dim = 1:20, reduction = &quot;integrated.cca&quot; ) Generado el grafo, Seurat realiza una optimización del paso anterior para finalmente agrupar las distintas células en comunidades. Para ello utiliza la función FindClusters, la cual además provee el parámetro resolution para controlar la granularidad del agrupamiento. Para el rango de células en el que estamos trabajando utilizar valores entre \\(0.4\\) y \\(1.2\\) es habitual. De forma arbitraria, en este caso se utilizará una resolución de \\(0.8\\). seurat_objects &lt;- FindClusters( seurat_objects, resolution = 0.8 ) 1.9 Reducción de la dimensionalidad no lineal (UMAP) 1.9.1 Utilidad del UMAP Las técnicas de reducción de la dimensionalidad no lineales pueden mostrar relaciones subyacentes en los datos que no hayan sido capturadas por técnicas lineales. En este caso, la técnica uniform manifold approximation and projection (UMAP) puede revelar alguna de estas relaciones no identificadas previamente por el PCA. Aunque esta técnica puede revelar relaciones ocultas, también se han de considerar sus limitaciones: este método preserva las distancias locales del conjunto de datos, a costa de ignorar las de mayor distancia. De esta forma, aunque la técnica puede revelar relaciones ocultas, no es recomendable utilizarla para hacer conclusiones, dado que muchas otras no se habrán considerado. 1.9.2 UMAP Es posible realizar un UMAP con la función Seurat::RunUMAP indicando las dimensiones a utilizar (dims) y la reducción de la dimensionalidad que queremos que utilice (reduction), en este caso en la que se han integrado los datos (integrated.cca) seurat_objects &lt;- RunUMAP( seurat_objects, dims = 1:20, reduction = &quot;integrated.cca&quot; ) 1.9.3 Visualización del UMAP Para visualizar las dimensiones generadas es posible utilizar la función Seurat::DimPlot. En ella simplemente se habrá de indicar la reducción que se quiere mostrar (reduction), en este caso el UMAP. DimPlot( seurat_objects, reduction = &quot;umap&quot;, label = TRUE ) Figura 1.4: Clusters en las dimensiones generadas por el UMAP 1.10 Búsqueda de genes expresados diferencialmente (DEG) Tras identificar los grupos de células es posible buscar los genes diferencialmente expresados en cada uno de ellos. Para esta tarea Seurat provee la función FindAllMarkers que busca los genes expresados en mayor o menor medida con respecto al resto de células que no pertenecen al cluster. all_markers &lt;- FindAllMarkers( seurat_objects ) La función devuelve una tabla con las siguientes columnas: p_val. Valor p para un gen al realizar un test de Suma de rangos de Wilcoxon. avg_log2FC. El log fold-change entre los dos grupos. El primer grupo se corresponderá con el cluster, el segundo con el resto de células que no pertenecen a él. pct.1. El porcentaje de células en el cluster que expresa el gen. pct.2. El porcentaje de células que expresan el gen y que no pertenecen al cluster. p_val_adj. El valor p ajustado por la corrección de Bonferroni usando todos los genes del conjunto de datos. 1.11 Selección de células 1.11.1 Filtrado de resultados significativos Obtenidos los DEGs y los clusters a los que pertenecen se pueden analizar los resultados, pero antes se habrán de seleccionar aquellos que sean significativos. Dado que se están realizando un gran número de pruebas (una por cada gen), se hará uso del p-valor ajustado por la corrección de Bonferroni, calculado en la sección anterior. Para realizar el filtrado de los resultados que cumplan la condición \\(\\text{p-valor} \\le 0.05\\), se utilizará la función dplyr::filter. significative_markers &lt;- all_markers %&gt;% filter(p_val_adj &lt;= 0.05) 1.11.2 Identificación de clusters Seleccionados los DEGs significativos, se pueden identificar los tipos celulares de cada cluster. En concreto, como en este caso se está trabajando con muestras de cáncer de próstata, la búsqueda se centrará en encontrar las células propias de este tejido, filtrando posibles contaminaciones. En otros estudios se han reportado marcadores genéticos de células luminales de próstata (Barclay et al. 2008), las contribuidoras principales al desarrollo del tumor y de la enfermedad. Los principales marcadores en este tipo de células son “Keratin 8” (KRT8) y “Keratin 18” (KRT18) por lo que se puede explorar si alguno de los cluster los expresa. significative_markers %&gt;% filter(gene == &quot;KRT18&quot; | gene == &quot;KRT8&quot;) %&gt;% arrange(desc(avg_log2FC), desc(avg_log2FC)) p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene KRT8.10 2.810e-88 3.427157 0.991 0.278 7.291e-84 14 KRT8 KRT18.10 2.285e-75 3.166531 0.963 0.311 5.929e-71 14 KRT18 KRT18.4 5.079e-37 2.569782 0.638 0.315 1.318e-32 7 KRT18 KRT8.4 3.345e-17 2.068169 0.489 0.290 8.681e-13 7 KRT8 KRT8.5 5.167e-63 1.968036 0.800 0.276 1.341e-58 8 KRT8 KRT18.5 3.253e-61 1.912306 0.831 0.307 8.442e-57 8 KRT18 KRT18.9 1.859e-10 -1.098934 0.042 0.342 4.824e- 6 13 KRT18 KRT8.2 1.460e- 9 -1.778397 0.136 0.316 3.790e- 5 3 KRT8 KRT8.9 1.951e-10 -1.903370 0.025 0.310 5.062e- 6 13 KRT8 KRT8.1 5.140e-12 -1.980353 0.119 0.318 1.334e- 7 2 KRT8 KRT8.3 4.372e- 8 -2.077888 0.154 0.313 1.134e- 3 5 KRT8 KRT18.2 1.375e-14 -2.251485 0.123 0.352 3.568e-10 3 KRT18 KRT18.1 3.994e-17 -2.290610 0.106 0.353 1.036e-12 2 KRT18 KRT18.3 1.026e-10 -2.345639 0.157 0.347 2.663e- 6 5 KRT18 KRT18.8 4.756e- 8 -2.448954 0.114 0.340 1.234e- 3 12 KRT18 Al ordenar los resultados por su avg_log2FC y pct.1, con la función dplyr::arrange, se observa que tanto KRT8 y KR18 se expresan en los mismos clusters. En concreto, en los clusters 8 y 14, los genes se encuentran en un alto porcentaje de las células y además con niveles de expresión relativamente altos. Para el caso del cluster 7, aunque presente niveles de expresión ligeramente superiores a los del cluster 8, no será seleccionado al presentar un porcentaje de expresión detectable muy bajo. Estos resultados pueden observarse de forma gráfica utilizando la función Seurat::FeaturePlot especificando los genes que se que quieren mostrar. FeaturePlot( seurat_objects, feature = c(&quot;KRT8&quot;, &quot;KRT18&quot;) ) Figura 1.5: Expresión de KRT8 y KRT18 en los clusters 8 y 14 De esta forma, se deduce que los clusters seleccionados se corresponden con células luminales de próstata y por tanto serán objeto de estudio. Por este motivo, se seleccionarán las células pertenecientes a estos clusters para analizarlas en pasos posteriores. luminal_cells &lt;- subset( seurat_objects, idents = c(8, 14) ) "],["cancer-cells-selection.html", "2 Selección de células cancerosas y marcadores 2.1 DEG en células luminales 2.2 Búsqueda de subpoblaciones 2.3 Selección de biomarcadores", " 2 Selección de células cancerosas y marcadores En esta sección se identificarán las células malignas entre las luminales previamente seleccionadas. Tras ello, los genes expresados por estas células serán seleccionados para análisis posteriores. 2.1 DEG en células luminales Los tejidos de cáncer de próstata presentan una gran heterogeneidad, incluso entre células del mismo tipo (Wasim, Lee, and Kim 2022), por este motivo es conveniente realizar una búsqueda de subpoblaciones en el conjunto de datos seleccionado. Esta búsqueda más detallada permite revelar información según los genes que expresen estas subpoblaciones, algunos ejemplos: Poblaciones con roles específicos. Genes diferencialmente expresados, dentro de un mismo tipo celular, pueden ser indicativos de subpoblaciones que realicen funciones específicas en el desarrollo de la enfermedad. Estado de las células. La presencia de ciertos marcadores puede indicar el estado en el que se encuentra un célula, e.g. células malignas o en proceso de carcinogénesis. 2.1.1 Caracterización y selección de los clusters Para la búsqueda de DEGs en los cluster seleccionados, se puede aplicar un proceso similar al de la sección anterior (1.10). La única diferencia será que en este caso se compararán células de clusters concretos, por lo que en su lugar, se usará la función Seurat::FindMarkers indicando en ident.1 e ident.2 el número de los clusters que se han de comparar. markers_cluster_8 &lt;- FindMarkers( luminal_cells, ident.1 = 8, ident.2 = 14 ) markers_cluster_14 &lt;- FindMarkers( luminal_cells, ident.1 = 14, ident.2 = 8 ) Realizada la búsqueda de biomarcadores, se seleccionarán aquellos resultados significativos. Además, para trabajar de forma más cómoda con ellos, se fusionarán en una sola tabla con la función dplyr::bind_rows y añadirá una nueva columna con el nombre de estos genes (tibble::rownames_to_column). markers_cluster_8 &lt;- markers_cluster_8 %&gt;% filter(p_val_adj &lt;= 0.05) %&gt;% mutate(cluster = 8) %&gt;% rownames_to_column(var = &quot;gene&quot;) markers_cluster_14 &lt;- markers_cluster_14 %&gt;% filter(p_val_adj &lt;= 0.05) %&gt;% mutate(cluster = 14) %&gt;% rownames_to_column(var = &quot;gene&quot;) markers &lt;- bind_rows(markers_cluster_8, markers_cluster_14) Tras seleccionar los genes expresados diferencialmente en cada uno de los clusters, se pueden identificar biomarcadores de relevancia en la enfermedad. Para visualizarlos de forma más simple y contrastar su expresión en ambos clusters, estos genes serán preseleccionados y ordenados por su nombre. genes &lt;- c( &quot;KLK3&quot;, &quot;FOLH1&quot;, &quot;NPY&quot;, &quot;LXN&quot;, &quot;SLPI&quot;, &quot;AGR2&quot;, &quot;CXCL1&quot;, &quot;DKK1&quot; ) filtered_markers &lt;- markers %&gt;% filter(gene %in% genes) %&gt;% arrange(gene) filtered_markers Entre los genes del cluster 8 es posible encontrar FOLH1, NPY y KLK3, genes identificados como biomarcadores de cáncer de próstata (Haberkorn et al. 2016; Ueda et al. 2013), en contraste con el cluster 14 donde se encuentran menos expresados. Además, los genes LXN y SLPI, identificados como supresores de la enfermedad (Thompson et al. 2008; Seed et al. 2019), se encuentran expresados en el cluster 14. Finalmente, el cluster 14 también expresa genes presentes en pacientes con la enfermedad como: AGR2, un biomarcador de orina de la enfermedad (Bu et al. 2011), además de CXCL1 y DKK1 biomarcadores relacionados con la progresión de la enfermedad e invasividad de los tumores (Browne et al. 2016; Benelli et al. 2013). Estas observaciones implican que ambos cluster contienen células con cierto grado de malignidad. Sin embargo, dado que las células del cluster 14 expresan genes supresores de la enfermedad, puede intuirse que se corresponden con células de próstata normales que están sufriendo un proceso de carcinogénesis. Es posible visualizar la expresión de los distintos genes con las siguientes gráficas. La figura 2.1 muestra los niveles de expresión de los distintos genes en cada uno de los clusters, mientras que, la figura 2.2 muestra un extracto del UMAP generado con todas las células y la expresión de los genes en cada una de ellas. VlnPlot( luminal_cells, idents = c(8, 14), features = genes ) Figura 2.1: Niveles de expresión en clusters 8 y 14 FeaturePlot( luminal_cells, features = genes, label = TRUE ) Figura 2.2: Expresión de genes en clusters 8 y 14 Considerando los resultados, se seleccionaran las células del cluster 8 para seguir trabajando con ellas. La razón para ello se debe a que en este trabajo se buscará evaluar biomarcadores de diagnóstico así como de estratificación de riesgo, de esta forma las células de este cluster serán más relevantes que células normales en proceso de transformación, es decir del cluster 14. 2.2 Búsqueda de subpoblaciones En la sección anterior se han seleccionado las células luminales que presentan cierto grado de malignidad. Sin embargo, como se ha explicado en la sección 2.1, también puede ser interesante comprobar si existe cierta variabilidad dentro del cluster. Expresado en otras palabras, es interesante comprobar si hay células con perfiles de expresión distintos, ya que puede ser indicativo de células con papeles concretos en el desarrollo de la enfermedad. 2.2.1 Repetición del flujo de trabajo Para comprobar la presencia de estas células basta con repetir el procedimiento realizado hasta ahora, con la única diferencia de que en lugar de utilizar el conjunto de datos al completo, se utilizarán solo las células del cluster seleccionado. Para realizar este proceso se seleccionarán en primer lugar las células del cluster 8 con la función subset, tras ello se definirá la función seurat_standard_workflow la cual realizará los primeros pasos del procedimiento descrito en la sección 1. malignant_luminal_cells &lt;- subset( luminal_cells, idents = 8 ) seurat_standard_workflow &lt;- function(seurat_object) { seurat_object &lt;- FindVariableFeatures(seurat_object) seurat_object &lt;- ScaleData( seurat_object, features = VariableFeatures(seurat_object) ) seurat_object &lt;- RunPCA( seurat_object, features = VariableFeatures(seurat_object) ) return(seurat_object) } malignant_luminal_cells &lt;- seurat_standard_workflow(malignant_luminal_cells) A la hora de seleccionar la dimensionalidad del conjunto de datos se utilizará el “método del codo”. Como se puede observar en la figura 2.3 la pendiente de la gráfica se reduce poco después de la componente número 10. Sin embargo, para mayor seguridad, se tomará hasta la componente 20 dado que en ella se puede observar una reducción todavía más pronunciada. ElbowPlot(malignant_luminal_cells, ndims = 50) Figura 2.3: Método del codo para las componentes del cluster 8 Finalmente, se realizará la búsqueda de nuevos clusters. Para ello se define la función seurat_cluster_search, la cual automatizará el proceso realizado en la sección anterior (1.8). seurat_cluster_search &lt;- function(seurat_object, dims, reduction = &quot;pca&quot;) { seurat_object &lt;- FindNeighbors( seurat_object, dims = dims, reduction = reduction ) seurat_object &lt;- FindClusters( seurat_object, resolution = 0.5 ) } malignant_luminal_cells &lt;- seurat_cluster_search( malignant_luminal_cells, 1:20 ) Realizada la búsqueda de nuevos clusters, se aplicará un UMAP para visualizar las células en sus respectivos clusters (figura 2.4). malignant_luminal_cells &lt;- RunUMAP( malignant_luminal_cells, dims = 1:20, reduction = &quot;pca&quot; ) DimPlot( malignant_luminal_cells, reduction = &quot;umap&quot;, label = TRUE ) Figura 2.4: UMAP de las células en el cluster 8 2.2.2 Interpretación de resultados En la figura 2.4 es posible observar 2 subgrupos relativamente bien separados. Una posible causa para su formación podría ser la heterogeneidad de las células cancerosas, como se ha explicado previamente en la sección 2.1. Por este motivo, es conveniente indentificar de nuevo genes diferenciados que arrojen algo de luz sobre el papel de cada una de estas posibles subpoblaciones. all_subpopulation_markers &lt;- FindAllMarkers( malignant_luminal_cells ) all_subpopulation_markers Una primera exploración sobre los DEG no revela información sobre el papel de los 2 subclusters identificados, por ello para intentar averiguar funciones concretas de los cluster se ha realizado un enriquecimiento funcional utilizando la herramienta provista por “The Gene Ontology consortium”. Para este proceso, solamente los genes con un avg_log2FC superior a \\(1\\) y p_val_adj igual o inferior a \\(0.05\\) han sido sido seleccionados. El cluster 1 cuenta con un reducido número de DEG significativos, los cuales parecen estar relacionados con el transporte de biomoléculas. Por otra parte, el cluster 0 presentan un gran número de DEG involucrados en procesos de transporte y metabólicos de distintas moléculas (ATP, iones, etc.) Aunque en la búsqueda de clusters haya realizado una separación, ambos cluster parecen presentar funciones relativamente similares. Ambos cluster tienen funciones enfocadas al transporte de moléculas, con la única de diferencia de tomar parte en algunos procesos metabólicos. Estas similitudes podrían hacer reconsiderar la validez de estos clusters como subpoblaciones. La formación de clusters no deja de ser un proceso matemático que se aplica al conjunto células. En este caso, esta técnica se ha aplicado para “aumentar la resolución” y así tratar de encontrar poblaciones de células más pequeñas. Matemáticamente estos resultados pueden ser coherentes, pero no hay una garantía de que tengan un significado biológico. Un error común con este tipo de procedimiento es aumentar demasiado la resolución, obteniendo así muchos cluster poco poblados, donde aunque células presenten similitudes relevantes puedan acabar en grupos distintos. De esta forma, la interpretabilidad de los resultados juega un papel crucial para no influir negativamente en los análisis posteriores. Trasladado a este caso, el cluster 8 ya contaba con un número bajo de células, con las cuales sí que se ha podido contrastar que se trataban de células luminales de próstata con cierta malignidad. Al volver a aplicar las técnicas de clustering y no poder validar las subpoblaciones obtenidas, se seguirá trabajando con el cluster 8 en su totalidad. 2.3 Selección de biomarcadores Una vez decidido que se trabajará con el cluster 8 en su totalidad se seleccionarán los biomarcadores de este grupo para su uso en análisis posteriores. Por este motivo, se seleccionarán los DEG sobreexpresados con respecto a los demás clusters (avg_log2FC &gt; 1). markers_cluster_8 &lt;- significative_markers %&gt;% filter(cluster == 8) %&gt;% filter(avg_log2FC &gt; 1) "],["count-matrix-generation.html", "3 Generación de la matriz de conteo 3.1 Descripción de los datos 3.2 Creación de matriz de conteo 3.3 Procesado de la matriz de conteo", " 3 Generación de la matriz de conteo En esta sección se trabajará con datos de experimentos de RNA-seq, los cuales han sido extraídos de TCGA, para generar una matriz de conteo con genes expresados en la enfermedad. Esta matriz será procesada en pasos posteriores para finalmente ser utilizada para evaluar el rendimiento de los diversos índices. 3.1 Descripción de los datos A la hora de trabajar con ellos, los datos descargados se encontrarán en el directorio ./tcga_data/. En este se podrán encontrar distintos subdirectorios y ficheros que se utilizarán durante el procesamiento de los datos: clinical. Directorio que contiene archivos de metadatos sobre los donantes de tejido. En su interior se encuentra el fichero clinical.tsv con variables de interés para el trabajo. gdc_download. Directorio que contiene, a su vez, distintos subdirectorios, cada uno de ellos con un archivo de lecturas para una muestra de tejido. gdc_sample_sheet. Fichero *.tsv que contiene información sobre los archivos descargados. En su mayoría, contiene identificadores de las muestras y archivos descargados, tipo de experimento, tipo de tumor, etc. Mayoritariamente es de utilidad para relacionar los archivos de metadatos con su respectiva muestra. 3.1.1 Preprocesamiento del fichero clinical y gdc_sample_sheet Dado que se trabaja con un gran número de ficheros de distinto tipo (datos clínicos, metadatos y datos de experimentos), es posible simplificar la tarea uniendo los ficheros de metadatos (gdc_sample_sheet.tsv) y datos clínicos (clinical.tsv) en un solo. Para esta tarea, se ha creado un script en python (tcga_metadata_processing.py)2. En concreto, los pasos realizados por el script son los siguientes: Lectura de los archivos Renombrado de las columnas para usar un estilo común Cambio de espacios por _ Uso de minúsculas Selección de variables de interés y muestras que las describan Puntuación de Gleason primaria Puntuación de Gleason secundaria Fusión de archivos utilizando identificadores del paciente case_id case_submitter_id Transformación de variables Transformación a tipo numérico Cálculo de nuevas variables Puntuación de Gleason3 Realizados estos pasos, el script genera el archivo file_clinical_sheet.csv, el cual contiene la información necesaria de cada archivo y las variables clínicas de cada paciente del que proviene la muestra. Finalmente, para trabajar con estos archivos, se guardaran las rutas en las que se encuentran. tcga_data_folder &lt;- &quot;./tcga_data/gdc_download_20240611_200434.803317&quot; file_clinical_path &lt;- &quot;./file_clinical_sheet.csv&quot; 3.2 Creación de matriz de conteo Como se ha descrito en el apartado anterior, se está trabajando con un gran número de archivos de lecturas. De forma similar a metadatos y datos clínicos, los archivos de lecturas pueden combinarse para facilitar su acceso a ellos, pero para realizar este proceso se ha de entender la estructura que presentan. Los archivos de lecturas con los que se está trabajando destinan sus 6 primeras líneas a una serie de métricas y nombres de las variables. Tras ellas, el resto de filas representan un gen con los valores de dichas variables. ## gene-model: GENCODE v36 gene_id gene_name gene_type unstranded stranded_first stranded_second tpm_unstranded fpkm_unstranded fpkm_uq_unstranded N_unmapped 1242436 1242436 1242436 N_multimapping 2589737 2589737 2589737 N_noFeature 1331220 16814349 16833920 N_ambiguous 3211136 753902 752634 ENSG00000000003.15 TSPAN6 protein_coding 2743 1379 1364 72.3539 20.8836 20.1004 ENSG00000000005.6 TNMD protein_coding 12 5 7 0.9728 0.2808 0.2702 ENSG00000000419.13 DPM1 protein_coding 745 398 347 73.8513 21.3158 20.5164 3.2.1 Importar archivos de lecturas Conociendo la estructura de los archivos es posible planificar una forma de automatizar el proceso para todos ellos. En primer lugar, se deberán de leer y para ello se define la función to_tsv. La función simplemente lee el archivo en la ruta especificada (file_path) omitiendo las 6 primeras lineas y utilizando un tabulador como elemento de separación. Tras ello, re-asigna el nombre de las columnas y devuelve la matriz generada. to_tsv &lt;- function(file_path) { column_names &lt;- c(&quot;gene_id&quot;, &quot;gene_name&quot;, &quot;gene_type&quot;, &quot;unstranded&quot;, &quot;stranded_first&quot;, &quot;stranded_second&quot;, &quot;tpm_unstranded&quot;, &quot;fpkm_unstranded&quot;,&quot;fpkm_uq_unstranded&quot;) counts &lt;- read_tsv(file_path, skip = 6, col_names = FALSE, show_col_types = FALSE) colnames(counts) &lt;- column_names return(counts) } 3.2.2 Selección de variables y renombrado Una vez es posible leer los conjuntos de datos es posible decidir que variables utilizar. Como se ha observado antes, los archivos de lecturas presentan las siguientes variables: gene_id y gene_name. Indican el acrónimo para el gen y su identificador. gene_type. Pequeña descripción del tipo de gen con el que se trata. unstranded. Número de lecturas que se alinean con la región de un gen, sin tener en cuenta la hebra de ADN en la que se encuentra. stranded_first y stranded_second. Número de lecturas que se alinean a la región de una hebra de ADN o su complementaria. tpm_unstranded, fpkm_unstranded y fpkm_uq_unstranded. Diversas normalizaciones de las lecturas en crudo. Respectivamente: transcritos por millón, fragmentos por kilobase por millón de lecturas y cuartil superior de FPKM. Al realizar análisis resulta más conveniente trabajar con identificadores frente a nombres, por lo que estos serán seleccionados. Con respecto a las métricas, se plantea la cuestión de si utilizar lecturas unstranded o paired (stranded_first y stranded_second). Habitualmente las segundas se suelen utilizar para experimentos donde es relevante conocer la hebra de la que proviene un transcrito, por ejemplo para el descubrimiento de novo de transcritos o estudio de isoformas (Conesa et al. 2016), por este motivo se escogerán las primeras. La segunda cuestión que se plantea es la normalización de los datos que se debe usar. Las lecturas normalizadas son de utilidad cuando se compara la expresión de distintos genes, ya que pueden normalizar parámetros que influyen en esta expresión, e.g., longitud del transcrito, tamaño de librería, etc. Puesto que se trabaja con muestras de distintos pacientes, resulta adecuado utilizar la métrica de transcritos por millón (TPM). Esta métrica normaliza las diferencias en la composición de transcritos en el denominador en lugar de simplemente dividir por el número de lecturas en la librería (Conesa et al. 2016), como se observa en (3.1). \\[ C_g = \\text{Número de lecturas alineadas al gen } g \\\\ L_g = \\text{Longitud del gen } g \\\\ N = \\text{Número total de genes} \\] \\[\\begin{equation} FPKM = \\dfrac{C_g*10^9}{(\\sum^N_{i=1} C_i)L_g} \\\\ TPM = \\dfrac{(C_g*10^3/L_g)*10^6}{\\sum^N_{i=1}(C_i*10^3/L_i)} \\tag{3.1} \\end{equation}\\] Identificadas las variables a utilizar, es posible definir una función para automatizar el proceso. La función rename_col utilizará como entrada una matriz de conteo (data) y un nombre que se le provea (sample_id), con ellos renombrará la columna tpm_unstranded al nombre especificado, más adelante se utilizará para indicar el identificador de la muestra. Finalmente, seleccionará dicha columna junto con la que contiene los identificadores de los genes. rename_col &lt;- function(data, sample_id) { count &lt;- data %&gt;% dplyr::rename(&quot;{ sample_id }&quot; := tpm_unstranded) %&gt;% dplyr::select(gene_id, all_of(sample_id)) return(count) } 3.2.3 Unión de archivos Estando automatizada la lectura de archivos y selección de variables de interés, solamente falta automatizar el proceso para unir estos archivos. Para esta tarea, se define join_count_matrices. La función tomará como entrada 2 matrices de conteo (count_matrix_a y count_matrix_b) y utilizará los identificadores de los genes (gene_id) para realizar su unión. De esta forma, si hay genes identificados en la segunda matriz que no están en la primera, se añadirá una nueva fila para dicho gen. En caso de que un gen exista en la primera matriz, las cuentas se colocarán en la fila adecuada. De esta forma la función devolverá una matriz donde cada fila se corresponderá a un gen concreto, mientras que cada columna a una muestra. join_count_matrices &lt;- function(count_matrix_a, count_matrix_b) { full_join( count_matrix_a, count_matrix_b, by = c(&quot;gene_id&quot;), keep = FALSE ) } 3.2.4 Construcción de la matriz de conteo Creadas las funciones para el flujo de trabajo, simplemente basta con poder aplicarlas a cada uno de los archivos de lecturas. Para que la tarea sea más sencilla, se realizará en primer lugar el preprocesado de los archivos y tras ello su unión. En primer lugar se define la función transform_counts, la cual simplemente aplica las funciones to_tsv y rename_col, definidas en las secciones 3.2.1 y 3.2.2. transform_counts &lt;- function(file_path, sample_id) { count_matrix &lt;- to_tsv(file_path) %&gt;% rename_col(sample_id) return(count_matrix) } La función toma como entrada la ruta de un archivo de lecturas y un identificador de muestra, por lo que para aplicar esta función a todos los archivos, se requerirá iterar sobre cada una de las rutas y sus identificadores. Esta información, está disponible en el archivo file_clinical_sheet.csv previamente generado (sección 3.1.1), por lo que se importará en primer lugar. Tras ello utilizando la función stringr::str_c es posible concatenar la ruta del directorio (tcga_data_folder) con el nombre de cada uno de los archivos (file_id y file_name) obteniendo así la ruta completa de cada uno de ellos. Estas rutas, se guardarán en una nueva columna (full_path) creada utilizando la función dplyr::mutate. Teniendo las rutas completas e identificadores, se usará la función purrr::map2 para iterar simultáneamente sobre 2 inputs y pasarlos en una función. En este caso, se aplicará sobre las rutas (file_clinical$full_path) y los identificadores de las muestras (file_clinical$sample_id) para pasarlos a la función transform_counts. De esta forma se obtendrá una lista de archivos de lecturas procesados. file_clinical &lt;- as.data.frame(read_csv(file_clinical_path, col_names = TRUE)) file_clinical &lt;- file_clinical %&gt;% mutate( full_path = str_c(tcga_data_folder, file_id, file_name, sep = &quot;/&quot;) ) count_matrices &lt;- map2( file_clinical$full_path, file_clinical$sample_id, transform_counts, .progress = T ) Preprocesados los archivos de lecturas, el siguiente pasó será realizar la unión de todos archivos. Para ello se utilizará la función purrr:reduce la cual combina los elementos de un vector en un valor único. De forma detallada, reduce actúa de la siguiente forma: Toma una función como input que es aplicada a los 2 primeros elementos de un vector. La función se aplica al nuevo resultado y al siguiente elemento del vector. El paso anterior se repite hasta que no queden más elementos en el vector. De esta forma, cuando se aplica reduce con la función join_count_matrices, se realizarán uniones de los ficheros de forma consecutiva hasta obtener una única matriz de conteo. merged_matrices &lt;- as.data.frame(purrr::reduce(count_matrices, join_count_matrices)) rownames(merged_matrices) &lt;- merged_matrices$gene_id 3.3 Procesado de la matriz de conteo Aunque en el paso anterior se ha generado una matriz de conteo, se debe tener en cuenta los posteriores análisis a realizar. En ellos, se deberán realizar una serie de cálculos sobre la matriz, por ello, será necesario que esta cumpla con algunas condiciones: Los genes o biomarcadores deberán encontrarse en las columnas de la matriz, dado que serán las variables de estudio. La matriz debe de contener una variable binaria que represente la variable a predecir e.g. si la muestra proviene de un paciente enfermo o no. 3.3.1 Pivotado de la matriz Como se ha descrito al comienzo de la sección, la estructura de los datos es relevante para realizar los análisis aguas abajo. Por este motivo, en esta sección se realizará una reestructuración de los mismos utilizando las funciones tidyr::pivot_longer y tidyr::pivot_wider. La primera, compactará todas la columnas especificadas (cols = !gene_id, es decir todas menos gene_id) en una nueva columna (names_to = \"sample\") y su valores en otra especificada (values_to = \"counts\"). Compactada la información de las muestras, podemos utilizar la segunda para crear nuevas columnas con el nombre de los genes (names_from = gene_id) que usen los valores previamente guardados (values_from = counts). tcga_data &lt;- merged_matrices %&gt;% pivot_longer( cols = !gene_id, names_to = &quot;sample&quot;, values_to = &quot;counts&quot; ) %&gt;% pivot_wider( names_from = gene_id, values_from = counts ) De esta forma, se logra que los genes se correspondan con las columnas y cada entrada con la muestra de un paciente. sample ENSG00000000003.15 ENSG00000000005.6 ENSG00000000419.13 TCGA-KK-A8IG-01A 29.0736 0.2262 76.9529 TCGA-G9-A9S7-01A 50.6646 0.0459 106.8449 TCGA-EJ-7789-11A 111.8758 1.2765 114.1114 TCGA-YL-A8SA-01A 51.1902 0.0597 90.8608 TCGA-XK-AAJ3-01A 36.0334 0.0000 63.9224 3.3.2 Cálculo de Gold Standards Una vez se ha reestructurado la matriz es posible incluir las variables a predecir, que se usarán en posteriores análisis. Estas variables, representarán patrones que suceden en la realidad o también conocidos como “Gold Standards”. En este caso los patrones que se incluirán en los datos serán variables binarias que, posteriormente, permitirán evaluar los genes seleccionados como predictores. Estas variables se establecerán a partir de la puntuación de Gleason, por lo que, el primer paso será incluirla en la matriz. Dado que el orden de las muestras es el mismo en la matriz que en la tabla de metadatos, es posible incluir la columna sin mayor dificultad. tcga_data[[&quot;gleason_score&quot;]] &lt;- file_clinical[[&quot;gleason_score&quot;]] Incluidas las puntuaciones de Gleason es posible generar las demás variables. En primer lugar se agruparán las muestras en función de la malignidad del tumor, es decir en función de su puntuación de Gleason: Puntuación de 5 o menor. Se podría considerar un cáncer de bajo grado. En el conjunto de datos utilizado, todos los tejido en este rango serán tejidos sanos (e.g. hiperplásias) Puntuación de 6 o 7. Cáncer de grado medio. En el conjunto de datos serán referidos como casos de malignidad baja. Puntuación de 8 o mayor. Cáncer de grado alto. En el conjunto de datos serán referidos como casos de malignidad alta. Con la función dplyr::mutate se creará la variable malignancy que ,utilizando la función dplyr::case_when, clasificará las distintas muestras en Normal, Low Malignancy y High Malignancy según los criterios establecidos. tcga_data &lt;- tcga_data %&gt;% mutate( malignancy = case_when( gleason_score &gt;= 8 ~ &quot;High Malignancy&quot;, gleason_score == 6 | gleason_score == 7 ~ &quot;Low Malignancy&quot;, gleason_score &lt;= 5 ~ &quot;Normal&quot; ) ) Es importante considerar que en pasos posteriores se deberá trabajar con variables binarias, por ello que se requerirá realizar transformaciones adicionales. En primer lugar, se buscará trabajar con biomarcadores de diagnóstico. Los biomarcadores de este tipo deberían ser capaces de diferenciar o clasificar entre pacientes sanos y enfermos, por ello, se utilizará la información de la variable malignancy para generar una variable que represente estas condiciones. Esta variable será disease que, utilizando la función forcats::fct_collapse, compactará los valores de malignancy de High Malignancy y Low Malignancy en 1 (enfermos), y valores de Normal en 0 (sanos). tcga_data &lt;- tcga_data %&gt;% mutate( disease = fct_collapse( malignancy, &quot;0&quot; = &quot;Normal&quot;, &quot;1&quot; = c(&quot;High Malignancy&quot;, &quot;Low Malignancy&quot;) ) ) En segundo lugar, se tratará de buscar biomarcadores de pronóstico o estratificación de riesgo. Los biomarcadores de este tipo deberían ser capaces de distinguir entre pacientes donde la enfermedad es menos probable que progrese frente a pacientes donde es más probable que lo haga, es decir un cáncer de crecimiento lento y menos agresivo frente a uno de crecimiento rápido y mayor agresividad. En este caso, se realizará un procedimiento similar creando la variable prognostic, donde 0 se corresponderá con valores de Low Malignancy y de 1 con High Malignancy4. tcga_data &lt;- tcga_data %&gt;% mutate( prognostic = fct_collapse( malignancy, &quot;0&quot; = &quot;Low Malignancy&quot;, &quot;1&quot; = &quot;High Malignancy&quot; ) ) Una vez generada la matriz con los genes y variables a predecir, el conjunto de datos está preparado para realizar los análisis pertinentes. Sin embargo, dado que anteriormente se han seleccionado biomarcadores relevantes de la enfermedad (sección 2), será posible utilizarlos para filtrar el conjunto de datos, de esta forma se logra: Aumento de precisión. Los experimentos de RNA-seq muestran perfiles transcripcionales promedios de todas las células de la muestra. Esto incluye células epiteliales, fibroblastos, células musculares, etc. Por este motivo, realizar un filtrado con los biomarcadores seleccionados en experimentos de scRNA-seq, permite seleccionar solamente aquellas células de interés para la enfermedad. Reducción del tamaño del conjunto de datos. Los análisis aguas abajo son exigentes a nivel computacional, por lo que una reducción del conjunto de datos acelera en gran medida el proceso. Así, en pasos posteriores, se realizará este filtrado usando los datos provenientes de experimentos de scRNA-seq, para finalmente realizar el análisis de los biomarcadores seleccionados de forma más óptima. El uso de un script de Python para esta tarea ha sido completamente arbitrario. Para algunos de los pasos este lenguaje utiliza una sintaxis más sencilla, sin embargo, estos también podrían haberse realizado con R.↩︎ La puntuación de Gleason se obtiene a través de la suma de la puntuación primaria y la secundaria: \\[\\text{P. Gleason} = \\text{P. Gleason Primaria} + \\text{P. Gleason Secundaria}\\]↩︎ En la creación de la variable prognostic solamente se deben considerar pacientes enfermos. Sin embargo, debido a que los datos provienen de la variable malignancy es posible encontrar encontrar casos de tejido sano, de esta forma la variable podrá tomar los valores: Normal, 0 y 1). Para mantener los datos en una matriz común, la variable prognosticse mantendrá en esta forma, pero a la hora de realizar los cálculos las entradas con valor Normal serán filtradas.↩︎ "],["count-matrix-filtering.html", "4 Filtrado de la matriz de conteo 4.1 Equivalencias entre identificadores 4.2 Filtrado por los genes identificados", " 4 Filtrado de la matriz de conteo En esta parte del trabajo se realizará un filtrado de la matriz generada en la sección anterior (sección 3). Para este paso, se utilizarán los biomarcadores seleccionados de experimentos de scRNA-seq (sección 2), reduciendo así el tamaño y ruido presente en los datos lo que facilitará los análisis posteriores. 4.1 Equivalencias entre identificadores Los formas para identificar los biomarcadores en los experimentos de scRNA-seq y los provenientes de TCGA son distintas. Los primeros utilizan el acrónimo del gen, mientras que los segundos utilizan identificadores de Ensembl. Para realizar el filtrado se deberán encontrar equivalencias entre los acrónimos e identificadores de Ensembl. Esta tarea es posible utilizando el paquete biomaRt(Durinck and Huber 2024), el cual permite acceder a diversos portales de información entre los que se encuentra Ensembl. En primer lugar, se usará la función biomaRt::useEnsembl para seleccionar la base de datos a la que acceder, en este caso genes, y el conjunto de datos a utilizar, en este caso hsapiens_gene_ensembl, es decir genes de humanos. ensembl &lt;- useEnsembl( biomart = &quot;genes&quot;, dataset = &quot;hsapiens_gene_ensembl&quot; ) La función preparará la configuración necesaria para conectar con Ensembl y realizar consultas a su base de datos, para esto último se usará la función biomaRt::getBM. getBM permite especificar una serie de atributos para la consulta, en este caso, se requerirá el nombre del gen (hgnc_symbol), su identificador de Ensembl (ensembl_gene_id) y posibles nombres alternativos para dicho gen (external_synonym). En la configuración de la función también se ha especificado el parámetro mart, que simplemente requiere el objeto con la configuración antes generada. Además de estos parámetros, la función también permite especificar filtros para recibir resultados más concretos. Habitualmente serían de utilidad, pero dado que para este caso se requerirá una lógica más compleja, por ello, en su lugar, se aplicarán filtrados propios en pasos posteriores. query_results &lt;- getBM( attributes = c( &quot;hgnc_symbol&quot;, &quot;ensembl_gene_id&quot;, &quot;external_synonym&quot; ), mart = ensembl ) hgnc_symbol ensembl_gene_id external_synonym MT-TF ENSG00000210049 MTTF MT-TF ENSG00000210049 TRNF MT-RNR1 ENSG00000211459 12S MT-RNR1 ENSG00000211459 MOTS-C MT-RNR1 ENSG00000211459 MTRNR1 MT-TV ENSG00000210077 MTTV Obtenidos los resultados de la consulta, antes de comenzar a trabajar con ellos, se compactará la columna de los nombres y sinónimos en una sola. De esta forma, será posible acceder a cualquier nombre y/o equivalente de forma más sencilla. id_equivalences &lt;- query_results %&gt;% pivot_longer( cols = !ensembl_gene_id, names_to = &quot;type&quot;, values_to = &quot;acronym&quot; ) %&gt;% distinct() ensembl_gene_id type acronym ENSG00000210049 hgnc_symbol MT-TF ENSG00000210049 external_synonym MTTF ENSG00000210049 external_synonym TRNF ENSG00000211459 hgnc_symbol MT-RNR1 ENSG00000211459 external_synonym 12S ENSG00000211459 external_synonym MOTS-C Generada la tabla de equivalencias, es conveniente comprobar que los biomarcadores seleccionados se encuentran en ella. De esta de forma, se asegura que sea posible asignarles un identificador. Realizando la intersección (dplyr::intersect) y la diferencia (dplyir::setdiff) entre los biomarcadores seleccionados y genes en la tabla de equivalencias, es posible identificar los genes que se han encontrado en la base de datos y los faltantes. missing_genes &lt;- setdiff(markers_cluster_8$gene, id_equivalences$acronym) finded_genes &lt;- intersect(markers_cluster_8$gene, id_equivalences$acronym) Una exploración de los genes faltantes en la base de datos revela una posible explicación para esta ausencia. Tomando como ejemplo el caso de RP11-356O9.1, una búsqueda en ensamblados anteriores (GRCh37.p13) permiten identificarlo por su nombre, sin embargo en casos posteriores (GRCh38.p14) no existe nombre alguno para dicho gen. Como sucede con este gen, puede darse el caso de correcciones de errores, es decir genes que inicialmente fueron identificados como distintos se combinan en una sola entrada cuando se descubre que puede tratarse del mismo. Alternativamente, el símbolo otorgado a estos genes se corresponde al establecido por HUGO Gene Nomenclature Commitee, por ello, en caso que un gen no haya recibido todavía un símbolo, este no estará disponible en la base de datos. Por estos casos, para incluir correcciones más recientes se usará el ensamblado más reciente (GRCh38.14). Además, en filtrados posteriores, los genes que presenten cierta arbitrariedad no serán considerados a fin de evitar posibles errores. 4.2 Filtrado por los genes identificados Seleccionados los genes con identificadores, se obtendrán aquellos que pertenezcan a los datos de interés. Además, para facilitar posteriores accesos, se añadirán los identificadores de Ensembl al conjunto de datos en una nueva variable (ensembl_gene_id). finded_markers &lt;- markers_cluster_8 %&gt;% filter(gene %in% finded_genes) %&gt;% left_join(id_equivalences, by = join_by(gene == acronym)) Es posible observar que cuando esta nueva columna es creada, se obtiene un mayor número de entradas del esperado. finded_markers %&gt;% group_by(ensembl_gene_id) %&gt;% filter(n() &gt; 1) %&gt;% arrange(ensembl_gene_id) p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ensembl_gene_id type 2.595e- 41 2.506852 0.338 0.057 6.734e- 37 8 APPL2 ENSG00000084234 external_synonym 4.533e- 32 1.679436 0.781 0.466 1.176e- 27 8 APLP2 ENSG00000084234 hgnc_symbol 2.430e-140 3.873963 0.544 0.042 6.304e-136 8 FAAH ENSG00000103089 external_synonym 3.242e- 29 3.556058 0.094 0.005 8.413e- 25 8 FA2H ENSG00000103089 hgnc_symbol 1.085e-137 3.244003 0.619 0.061 2.815e-133 8 HOMER2 ENSG00000103942 hgnc_symbol 4.675e- 25 1.239922 0.481 0.159 1.213e- 20 8 CPD ENSG00000103942 external_synonym 2.082e- 23 1.635001 0.175 0.027 5.403e- 19 8 PEX11G ENSG00000104883 hgnc_symbol 2.082e- 23 1.635001 0.175 0.027 5.403e- 19 8 PEX11G ENSG00000104883 external_synonym 4.765e- 19 1.270936 0.231 0.054 1.236e- 14 8 PEX11B ENSG00000131779 hgnc_symbol 4.765e- 19 1.270936 0.231 0.054 1.236e- 14 8 PEX11B ENSG00000131779 external_synonym 5.375e- 52 2.313213 0.244 0.023 1.395e- 47 8 PVRL4 ENSG00000143217 external_synonym 3.857e- 13 2.783755 0.175 0.045 1.001e- 8 8 PRR4 ENSG00000143217 external_synonym 7.129e- 55 3.215818 0.275 0.028 1.850e- 50 8 PEX11A ENSG00000166821 hgnc_symbol 7.129e- 55 3.215818 0.275 0.028 1.850e- 50 8 PEX11A ENSG00000166821 external_synonym 3.469e- 21 1.188366 0.656 0.342 9.002e- 17 8 MRPL41 ENSG00000182154 hgnc_symbol 1.039e- 18 1.511851 0.569 0.253 2.697e- 14 8 MRPL27 ENSG00000182154 external_synonym 6.868e-122 4.225360 0.525 0.048 1.782e-117 8 SCD ENSG00000197375 external_synonym 8.673e- 64 3.286203 0.356 0.041 2.250e- 59 8 SLC22A5 ENSG00000197375 hgnc_symbol Comprobando las distintas entradas es posible observar como algunos genes presentan el mismo identificador de Ensembl. Estas duplicaciones han sido generadas durante la creación de la columna ensembl_gene_id, debido a uno de los siguientes casos: El sinónimo (external_sinonym) y nombre del gen (hgnc_symbol) son iguales, introduciendo información duplicada (e.g. PEX11G). El sinónimo y nombre del gen son distintos, introduciendo dos entradas (e.g. APPL2 y APLP2). Para solventar esta redundancia en la información, se realizará un filtrado siguiendo los siguientes criterios: Si un ensembl_gene_id es único. La entrada se conservará (n() == 1)). Si un ensembl_gene_id no es único. Entre las entradas que usen dicho identificador, se conservará el nombre del gen y descartarán posibles sinónimos (type == \"hgnc_symbol\"). En caso de que todas las entradas sean sinónimos se seleccionará, de forma arbitraria, el primer sinónimo que aparezca en los datos. filtered_markers &lt;- finded_markers %&gt;% group_by(ensembl_gene_id) %&gt;% filter( case_when( n() == 1 ~ TRUE, n() &gt; 1 &amp; (type == &quot;hgnc_symbol&quot;) ~ TRUE, n() &gt; 1 &amp; (gene == gene[[1]]) &amp; all(cumall(type == &quot;external_synonym&quot;)) ~ TRUE, .default = FALSE ) ) Una exploración más detallada de los datos muestra el caso opuesto, genes con el mismo nombre presentando 2 identificadores de ensemble distintos, e.g. PRR4 con los identificadores: ENSG00000111215, ENSG00000263247 y ENSG00000282269. Esta duplicidad es conveniente, puesto que es posible asegurar a que identificador se hace referencia en los experimentos. Además, no afecta negativamente, puesto que aunque posean identificadores distintos los valores de expresión para estos genes serán idénticos. Filtrados los biomarcadores, se podrán seleccionar los genes del conjunto de datos extraído de TCGA. Para ello, en primer lugar, se renombrarán las columnas eliminando la versión de los identificadores de ellas y los genes conteniendo “PAR_Y” en su identificador, puesto que no están expresados y pueden generar conflictos de identificadores duplicados. En segundo lugar, se seleccionarán las columnas (genes) que coincidan con los identificadores seleccionados. roc_data &lt;- tcga_data %&gt;% select( -contains(&quot;PAR&quot;) ) %&gt;% rename_with( \\(x) str_replace(x, &quot;\\\\..*$&quot;, &quot;&quot;) ) %&gt;% select( contains(filtered_markers$ensembl_gene_id) | c(&quot;sample&quot;, &quot;gleason_score&quot;, &quot;disease&quot;, &quot;malignancy&quot;, &quot;prognostic&quot;) ) De esta forma, el conjunto de datos resultante contiene 2651 variables (exceptuando variables respuesta e identificadores de muestra). Como se ha explicado previamente, es posible que existan genes con identificadores distintos, sin embargo, se puede realizar un conteo del número de genes únicos que en realidad se han seleccionado. genes_in_tcga &lt;- filtered_markers$ensembl_gene_id %in% colnames(roc_data) markers_in_tcga &lt;- filtered_markers[which(genes_in_tcga), ] length(unique(markers_in_tcga$gene)) ## [1] 2584 En pasos anteriores, cuando se seleccionaron los biomarcadores comunes entre los obtenidos en las muestras y los disponibles en Ensembl, se encontraron 2585; y de estos, 2584 se han encontrado en las muestras del TCGA. Con estos genes, será con los que se trabaje a la hora de realizar los análisis posteriores. "],["index-evaluation.html", "5 Evaluación de índices 5.1 AUCs 5.2 pAUC 5.3 Índices derivados de pAUC 5.4 Comparación de índices 5.5 Resultados 5.6 Discusión y conclusiones", " 5 Evaluación de índices En esta sección del trabajo se estudiarán los distintos índices aplicados a los biomarcadores de la sección anterior. En primer lugar, se describirá el fundamento teórico y limitaciones de cada uno de ellos. Tras ello, estos índices serán aplicados al conjunto de datos utilizando las distintas variables respuesta. Finalmente, se evaluará su capacidad para seleccionar los biomarcadores de mayor rendimiento, además de contrastar sus resultados con otros de utilidad aplicados actualmente en la práctica. Para esta sección necesitaremos el conjunto de datos generado en la anterior sesión. El conjunto de datos contiene los niveles de diversos genes expresados en células luminales de próstata de pacientes con cáncer. 5.1 AUCs 5.1.1 Introducción En la literatura, 2 de las aproximaciones estadísticas más usadas para evaluar y comparar el rendimiento de una función o clasificador binario han sido las curvas \\(ROC\\) (Característica Operativa del Receptor) y el área bajo dichas curvas (\\(AUC\\)). El principal objetivo de un clasificador binario es discriminar instancias con una condición de interés. Su precisión viene determinada por 2 métricas: su sensibilidad y su especificidad o, de forma equivalente la tasa verdaderos positivos (\\(TPR = Sensitivity\\)) y de falsos positivos (\\(FPR = 1 - Specificity\\)). Cuando se trabaja con marcadores continuos, estos pueden ser dicotomizados en instancias positivas y negativas seleccionando una de las puntuaciones del marcador como un punto de corte, o umbral de decisión. Una curva \\(ROC\\) representa los valores de \\(TPR\\) y \\(FPR\\) para cada uno de los umbrales de decisión de un marcador. Dado que estos puntos se calculan para todo un rango de umbrales, el \\(AUC\\) actúa como una métrica global mostrando los intercambios entre ambos parámetros de la curva, es decir, mostrando la ganancia o perdida de una métrica frente a otra. 5.1.2 Cálculo de AUCs para diagnóstico Comprendido el fundamento teórico es posible realizar los cálculos. Para ello, se utilizará la función pROC::auc, la cual calculará el \\(AUC\\) utilizando una variable para hacer una predicción (predictor) y una variable que contenga la respuesta a dicha predicción, es decir la condición de interés, variable respuesta o gold standard (response). La función requiere que la variable respuesta sea de tipo factor y utilice solamente 2 valores, donde el primero se corresponda con los casos sin la condición de estudio y el segundo con ella. En el conjunto de datos con el que se trabaja, la variable respuesta toma valores de 0 y 1 para indicar los casos con la condición de estudio y sin ella. Sin embargo, si se comprueba el orden de estos valores, se observa que está invertido. levels(roc_data$disease) ## [1] &quot;1&quot; &quot;0&quot; Por este motivo, antes de realizar el cálculo de los \\(AUC\\)s, se reorganizarán los valores de disease. Para esta tarea se utilizará la función forcats::fct_relevel, la cual tomará como entrada un factor y un vector indicando el nuevo orden para sus clases. roc_data$disease &lt;- fct_relevel(roc_data$disease, c(&quot;0&quot;, &quot;1&quot;)) levels(roc_data$disease) ## [1] &quot;0&quot; &quot;1&quot; Ordenadas las clases en la variable respuesta, es posible aplicar la función pROC::auc. Dado que se buscará aplicar la métrica a todos los genes, se obtendrá un conjunto de datos temporal que contendrá solo los genes (diagnostic_dataset) y se utilizará la función purrr::map_dbl sobre este. La función iterará sobre las columnas (marcadores) y aplicará la función pROC::auc sobre cada una de ellas utilizando la variable disease como respuesta. diagnostic_dataset &lt;- roc_data %&gt;% select( -c(&quot;sample&quot;, &quot;gleason_score&quot;, &quot;malignancy&quot;, &quot;disease&quot;, &quot;prognostic&quot;) ) auc_diagnostic &lt;- map_dbl( diagnostic_dataset, auc, response = roc_data$disease, direction = &quot;&lt;&quot;, quiet = TRUE, .progress = TRUE ) 5.1.3 Cálculo de AUCs para pronóstico De forma similar a la sección anterior, es posible calcular las \\(AUC\\)s pero esta vez en un contexto de pronóstico para la enfermedad. Sin embargo, esta sección requerirá de un filtrado previo: hasta ahora se estaba trabajando tanto con tejidos sanos como con enfermos, sin embargo, para este contexto solamente serán necesarios casos con la enfermedad. Para realizar este primer filtrado, se generará un conjunto de datos temporal con los pacientes enfermos (disease == 1). A continuación, se reorganizarán las clases de la variable (prognostic) y eliminarán las que no son utilizadas (Normal, aquellas correspondientes a pacientes sanos). disease &lt;- roc_data %&gt;% filter(disease == 1) disease[[&quot;prognostic&quot;]] &lt;- fct_drop(disease[[&quot;prognostic&quot;]]) disease[[&quot;prognostic&quot;]] &lt;- fct_relevel(disease[[&quot;prognostic&quot;]], c(&quot;0&quot;, &quot;1&quot;)) Realizado el filtrado, se realizará un procedimiento similar para calcular las \\(AUC\\)s en este nuevo contexto. prognostic_dataset &lt;- disease %&gt;% select( -c(&quot;sample&quot;, &quot;gleason_score&quot;, &quot;malignancy&quot;, &quot;disease&quot;, &quot;prognostic&quot;) ) auc_prognostic &lt;- map_dbl( prognostic_dataset, auc, response = disease$prognostic, direction = &quot;&lt;&quot;, quiet = TRUE, .progress = TRUE ) 5.2 pAUC 5.2.1 Introducción En ciertos contextos, el estudio de la curva \\(ROC\\) en su totalidad no es de interés. En aplicaciones médicas y en otros campos, suelen seleccionarse ciertos rangos de la curva debido al interés por unos valores concretos de \\(TPR\\) o \\(FPR\\). Por ejemplo, en un contexto de diagnóstico, un biomarcador con un bajo \\(FPR\\) (alta especificidad) es relevante a la hora de confirmar la presencia de una condición (“rule in”), dado que es muy improbable que se de un falso positivo. Mientras que un biomarcador con un alto \\(TPR\\) (alta sensibilidad) es relevante para descartar la presencia de una condición (“rule out”), dado que es muy improbable que se de un falso negativo. En este tipo de situaciones, el área parcial de la curva \\(ROC\\) (\\(pAUC\\)) atrae mucha más atención como métrica, ya que sintetiza la información en la región de interés en lugar de en toda la curva. 5.2.2 Cálculo de pAUCs en regiones de alta especificidad Un diagnóstico temprano de ciertas enfermedades, como es el caso del cáncer de próstata, es de gran importancia dado que puede mejorar el pronóstico de un paciente en gran medida (Wang and Chang 2011). Sin embargo, el tratamiento de estas enfermedades puede ser agresivo y por tanto debe considerarse cuidadosamente. En este contexto, es conveniente reducir los casos en los que se trata a pacientes sanos, es decir el número de falsos positivos, por ello se requieren condiciones de alta especificidad. Con el fin de trabajar en estas condiciones se seleccionarán arbitrariamente rangos de \\(1 - FPR\\) contenidos en un intervalo de \\((0.9, 1)\\). Para realizar estos cálculos se usará de nuevo la función pROC::auc indicando que se trabajará sobre el rango indicado (partial.auc = c(0.9, 1)) y sobre la especificidad (partial.auc.focus = \"spec\"). pauc_sp_diagnostic &lt;- map_dbl( diagnostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;spec&quot;, response = roc_data$disease, direction = &quot;&lt;&quot;, quiet = T, .progress = T ) De forma similar, determinar el pronóstico de un paciente es relevante para seleccionar un tratamiento más o menos agresivo. Cometer falsos positivos en este contexto implica consecuencias graves para el paciente, por este motivo, también se considerarán condiciones de alta especificidad para determinar un pronóstico. pauc_sp_prognostic &lt;- map_dbl( prognostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;spec&quot;, response = disease$prognostic, direction = &quot;&lt;&quot;, quiet = T, .progress = T ) 5.2.3 Cálculo de pAUCs en regiones de alta sensibilidad De forma similar, es posible trasladar el caso a condiciones de alta sensibilidad. Una alta sensibilidad se requiere en enfermedades que son fatales si no son tratadas, es decir, cometer un falso negativo implica la muerte del paciente. De esta forma, cuando un mal pronóstico para la enfermedad implica graves consecuencias, se debe considerar una alta sensibilidad. De este modo, para calcular los índices, simplemente se realizará el procedimiento anterior pero esta vez indicando que se utilizará la sensibilidad (partial.auc.focus = \"sens\"). pauc_sn_prognostic &lt;- map_dbl( prognostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;sens&quot;, response = disease$prognostic, direction = &quot;&lt;&quot;, quiet = T, .progress = T ) Finalmente, desde el punto de vista clínico también es relevante un contexto de alta sensibilidad para el diagnóstico de la enfermedad. Como se ha explicado antes, un diagnóstico temprano puede ser relevante para evitar la muerte del paciente. Por este motivo, también debería considerarse esta métrica para realizar los cálculos. pauc_sn_diagnostic &lt;- map_dbl( diagnostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;sens&quot;, response = roc_data$disease, direction = &quot;&lt;&quot;, quiet = T, .progress = T ) 5.3 Índices derivados de pAUC 5.3.1 Problemas del pAUC Aunque el \\(pAUC\\) puede ser útil para trabajar en regiones de interés en la curva \\(ROC\\), no está libre de fallas. Este índice ha sido cuestionado por su falta de interpretabilidad, ya que aunque algunos biomarcadores presentan valores altos de \\(AUC\\) y rinden bien en las zonas seleccionadas, presentan valores de \\(pAUC\\) muy cercanos a 0. Esto puede comprobarse, por ejemplo, con los 10 biomarcadores de mayor \\(AUC\\) en condiciones de alta especificidad: enframe(auc_diagnostic) %&gt;% arrange(desc(value)) %&gt;% left_join( enframe(pauc_sp_diagnostic), join_by(name == name) ) %&gt;% dplyr::rename( auc = value.x, pauc = value.y ) %&gt;% .[0:10,] name auc pauc ENSG00000105707 0.9436868 0.0746093 ENSG00000181378 0.9252605 0.0749387 ENSG00000124839 0.9229620 0.0680432 ENSG00000006625 0.9207784 0.0553402 ENSG00000242110 0.9157217 0.0672311 ENSG00000159263 0.9103203 0.0528042 ENSG00000138028 0.9091710 0.0505440 ENSG00000173638 0.9071407 0.0513178 ENSG00000245750 0.9061063 0.0549264 ENSG00000176058 0.9044591 0.0604658 Como se observa, los \\(pAUC\\) no superan el \\(0.5\\); valor límite en el \\(AUC\\) con el que se considera que un clasificador rinde igual que uno completamente aleatorio. Además, en ciertos escenarios, el \\(pAUC\\) no puede distinguir que clasificador presentaría un mejor rendimiento. Por ejemplo, cuando se comparan clasificadores con \\(pAUC\\)s iguales y curvas \\(ROC\\) que se cruzan (H. Ma, Bandos, and Gur 2015). Para lidiar con estas limitaciones, distintas transformaciones del \\(pAUC\\) se han desarrollado para trabajar en condiciones de alta sensibilidad y especificidad. 5.3.2 Índices para la especificidad 5.3.2.1 SpAUC Una de las primeras transformaciones descritas es el área parcial bajo la curva estandarizada (\\(SpAUC\\)), propuesto por McClish (1989). Esta transformación trabaja sobre un rango concreto de especificidad, \\((FPR_1, FPR_2)\\), donde los valores que puede tomar el \\(pAUC\\) se escalan a valores dentro del intervalo \\((0.5, 1)\\) haciendo que la métrica sea más interpretable. El límite superior para el área del \\(pAUC\\) está definido por el rectángulo formado por los puntos: \\((FPR_1, 0), (FPR_2, 0), (FPR_1, 1)\\) y \\((FPR_2, 1)\\). Mientras que, el límite inferior está definido por el trapecio con puntos: \\((FPR_1, 0), (FPR_2, 0), (FPR_1, FPR_1)\\) y \\((FPR_2, FPR_2)\\), el cual coincide con la diagonal de la curva. Si se desarrollan las áreas de los límites superior e inferior, el área que puede tomar \\(pAUC\\) (\\(A\\)) está definida de la siguiente forma: \\[\\begin{equation} \\dfrac{1}{2}(FPR_2 - FPR_1)(FPR_2 + FPR_1) \\le A \\le FPR_2 - FPR_1 \\tag{5.1} \\end{equation}\\] Finalmente, aplicando la siguiente transformación (5.2), se logra que el índice tome un valor de \\(1\\) cuando \\(A = \\text{max}\\) y un valor de \\(0.5\\) cuando \\(A = \\text{min}\\), escalando el \\(pAUC\\) al área total. \\[\\begin{equation} \\dfrac{1}{2}\\left[1 + \\dfrac{A - \\text{min}}{\\text{max} - \\text{min}} \\right] \\tag{5.2} \\end{equation}\\] A pesar de la mejora en su interpretabilidad, la métrica todavía presenta algunas limitaciones. En la práctica, las curvas \\(ROC\\) suelen atravesar la diagonal, por lo que, el límite inferior definido en (5.1) no estará bien definido en estos casos. Además, el índice no solventa el problema de comparar 2 clasificadores con igual \\(pAUC\\) y curvas \\(ROC\\) que se cruzan. Conociendo las ventajas y limitaciones de la métrica, esta se aplicará al conjunto de datos para contrastarla con otras más adelante. Para ello se utilizará la función pROC::auc indicando el argumento partial.auc.correct = TRUE, que aplicará la transformación descrita por McClish. Además, se indicará el parámetro allow.invalid.partial.auc.correct = FALSE, de esta forma, la función no calculará el índice cuando la curva se encuentra descrita por debajo del área mínima, puesto que el límite inferior no estará bien definido, devolviendo en su lugar un NA. spauc_sp_diagnostic &lt;- map_dbl( diagnostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;spec&quot;, partial.auc.correct = TRUE, allow.invalid.partial.auc.correct = FALSE, response = roc_data$disease, direction = &quot;&lt;&quot;, quiet = TRUE, .progress = TRUE ) spauc_sp_prognostic &lt;- map_dbl( prognostic_dataset, auc, partial.auc = c(0.9, 1), partial.auc.focus = &quot;spec&quot;, partial.auc.correct = TRUE, allow.invalid.partial.auc.correct = FALSE, response = disease$prognostic, direction = &quot;&lt;&quot;, quiet = TRUE, .progress = TRUE ) 5.3.2.2 TpAUC Para solventar los problemas que presenta el \\(SpAUC\\), Vivo, Franco, and Vicari (2018) han propuesto una transformación alternativa para regiones de alta especificidad, el denominado tighter partial area index (\\(TpAUC\\)). Este nuevo índice define límites más ajustados que el anterior y considera la forma que adopta una curva \\(ROC\\), es decir, es compatible con curvas definidas por debajo de la diagonal o inadecuadas. Los límites iniciales propuestos por el \\(TpAUC\\) parten de los establecidos por el \\(SpAUC\\), (5.1). Sin embargo, Vivo et al. proponen que estos límites pueden ajustarse a las regiones donde la curva se encuentre definida. Es decir, estos límites se ajustan a los puntos de la curva presentes en la región de interés, donde \\(TPR_i = TPR(FPR_i)\\) para \\(i = 1,2\\). Estos límites ajustados se definen de la siguiente forma: \\[\\begin{equation} TPR_1(FPR_2 - FPR_1) \\le A \\le TPR_2(FPR_2-FPR_1) \\tag{5.3} \\end{equation}\\] El nuevo límite inferior es más consistente, ajustándose a la forma de la curva incluso cuando estas no son adecuadas, es decir, están definidas por debajo de la línea del azar. Sin embargo, cuando las curvas \\(ROC\\) son adecuadas, se pueden describir límites más ajustados. Por definición, estas curvas son siempre no decrecientes, por lo que los siguientes límites podrían ser descritos: \\[\\begin{equation} \\text{max}\\left\\{TPR_1(FPR_2 - FPR_1), \\dfrac{1}{2}(FPR_2 - FPR_1)(FPR_2 + FPR_1)\\right\\} \\le \\\\ A \\le TPR_2(FPR_2-FPR_1) \\tag{5.4} \\end{equation}\\] Finalmente, se pueden encontrar límites más ajustados cuando las curvas son cóncavas. Una curva \\(ROC\\) cóncava presenta un ratio de probabilidad positivo (\\(PLR(t) = ROC(t)/t\\)) decreciente, es decir, este alcanza valores mínimos en el extremo superior de la curva. Así, si esta condición se cumple en la región de interés, se puede describir un nuevo límite inferior. Este límite más ajustado se corresponde con el trapecio de puntos: \\((FPR_1,0), (FPR_2, 0), (FPR_1, TPR_2)\\) y \\((FPR_2, TPR_2)\\), que considerando su área se obtiene la siguiente expresión: \\[\\begin{equation} \\dfrac{1}{2}(TPR_1+TPR_2)(FPR_2-FPR_1) \\le A \\le TPR_2(FPR_2-FPR_1) \\tag{5.5} \\end{equation}\\] Descritos los límites y condiciones donde se aplican, es posible utilizar la transformación descrita por McClish (5.2) para encapsular los valores en el rango \\((0.5, 1)\\). Tras aplicar la transformación el resultado obtenido se corresponde con el \\(TpAUC\\). De forma similar al \\(SpAUC\\), el \\(TpAUC\\) se aplicará en el conjunto de datos para más tarde contrastarlo con las demás métricas. El algoritmo para calcular el \\(TpAUC\\) se encuentra implementado en el paquete ROCpAI de Bioconductor, concretamente, en la función ROCpAI::tpAUC. La función tpAUC requiere de indicar la región de la curva en la que aplicar los cálculos (low.value y up.value) y el conjunto de datos. Este último requerirá que la primera columna se corresponda con la variable respuesta, mientras que el resto con los demás predictores. tpauc_sp_diagnostic_assay &lt;- tpAUC( dataset = diagnostic_dataset %&gt;% mutate( disease = roc_data$disease, .before = 1 ), low.value = 0, up.value = 0.1, plot = FALSE ) tpauc_sp_prognostic_assay &lt;- tpAUC( dataset = prognostic_dataset %&gt;% mutate( prognostic = disease$prognostic, .before = 1 ), low.value = 0, up.value = 0.1, plot = FALSE ) La salida de la función devolverá un objeto con diversas métricas. Utilizando la función assay se podrán extraer los \\(TpAUC\\) almacenados en St_pAUC. Finalmente, los identificadores de cada clasificador se asignarán a cada uno de los resultados. tpauc_sp_diagnostic &lt;- as.numeric(assay(tpauc_sp_diagnostic_assay)$St_pAUC) tpauc_sp_prognostic &lt;- as.numeric(assay(tpauc_sp_prognostic_assay)$St_pAUC) names(tpauc_sp_diagnostic) &lt;- colnames(diagnostic_dataset) names(tpauc_sp_prognostic) &lt;- colnames(prognostic_dataset) 5.3.3 Índices para la sensibilidad 5.3.3.1 NpAUC El índice normalized partial area (\\(NpAUC\\)), propuesto por Y. Jiang, Metz, and Nishikawa (1996), fue uno de los primeros enfocados en regiones de alta sensibilidad. Este índice es conceptualmente similar al \\(SpAUC\\), salvo que en este caso son \\(TPR_1 = TPR_0\\) y \\(TPR_2 = 1\\) los que definen sus límites superior e inferior. Concretamente, estos límites están definidos como: El rectángulo de puntos \\((1,1), (1, TPR_0), (0, 1)\\) y \\((0, TPR_0)\\), es decir, de longitud \\(1\\) y altura dado por la banda \\(1 - TPR_0\\). El triángulo de puntos \\((TPR_0, TPR_0), (1, TPR_0)\\) y \\((1,1)\\). Estos límites, de forma desarrollada, quedan expresados de la siguiente forma: \\[\\begin{equation} \\dfrac{1}{2}(1 - TPR_0)^2 \\le A \\le 1 - TPR_0 \\tag{5.6} \\end{equation}\\] Para realizar la normalización, cada término se divide entre el límite superior (\\(1 - TPR_0\\)) generando la expresión: \\[\\begin{equation} \\dfrac{1}{2}(1-TPR_0) \\le \\dfrac{A}{1 - TPR_0} \\le 1 \\tag{5.7} \\end{equation}\\] Así, el \\(NpAUC\\) se corresponde con el término central, quedando definido como: \\[\\begin{equation} NpAUC = \\dfrac{A}{1 - TPR_0} \\tag{5.8} \\end{equation}\\] Debido a esta transformación, el \\(NpAUC\\) se puede interpretar como el valor promedio de la especificidad para los valores de sensibilidad por encima de \\(TPR_0\\). Sin embargo, a pesar de ser más interpretable el índice sigue presentando desventajas. En primer lugar, el \\(NpAUC\\) puede tomar valores inferiores a \\(0.5\\), dificultando su interpretación. En segundo lugar, no es capaz de distinguir clasificadores con igual \\(pAUC\\) y curvas \\(ROC\\) que se cruzan, independientemente de su forma. Igual que en los casos anteriores, el \\(NpAUC\\) se aplicará al conjunto de datos para contrastarlo más adelante. El índice no está implementado en ningún paquete conocido, de modo que para aplicarlo de forma sencilla se ha incluido en un paquete propio, ROCnGO. Este paquete cuenta con la función ROCnGO::np_auc que permite calcular el índice con un procedimiento similar a los anteriores. npauc_sn_diagnostic &lt;- map_dbl( diagnostic_dataset, \\(gene) { np_auc( predictor = gene, response = roc_data$disease, lower_tpr = 0.9 ) }, .progress = TRUE ) npauc_sn_prognostic &lt;- map_dbl( prognostic_dataset, \\(gene) { np_auc( predictor = gene, response = disease$prognostic, lower_tpr = 0.9 ) }, .progress = TRUE ) 5.3.3.2 FpAUC De forma similar al \\(TpAUC\\) con respecto al \\(SpAUC\\), Franco and Vivo (2021) propusieron el fitted partial area index (\\(FpAUC\\)) para solventar las desventajas del \\(NpAUC\\) en rangos de alta sensibilidad. Este nuevo índice buscaba: Ser interpretable como métrica de diagnóstico. Esto incluye ser igual a \\(AUC\\) cuando \\(TPR_0 = 0\\). Aplicarse a cualquier forma de la curva \\(ROC\\), incluyendo las inadecuadas. Distinguir dos clasificadores con \\(pAUC\\) iguales y que sus curvas \\(ROC\\) se crucen. Para realizar el cálculo del \\(FpAUC\\) se requiere definir nuevos límites para el \\(pAUC\\) en condiciones de alta sensibilidad, para ello, se partirá de los límites iniciales definidios en \\(NpAUC\\) (5.6). En primer lugar, un nuevo límite superior puede ser definido. Este nuevo límite puede ajustarse a la zona donde se encuentre definida la curva, es decir, al rectángulo de puntos \\((FPR_0, TPR_0), (FPR_0, 1), (1, TPR_0)\\) y \\((1,1)\\) donde \\(FPR_0 = FPR(TPR_0)\\). Desarrollando el área de este rectángulo se obtiene la siguiente expresión (5.9). \\[\\begin{equation} \\dfrac{1}{2}(1 - TPR_0)^2 \\le A \\le (1-FPR_0)(1 - TPR_0) \\tag{5.9} \\end{equation}\\] Como se ha explicado anteriormente en la sección 5.3.2.2, las curvas \\(ROC\\) son funciones monótonas no decrecientes. Esto no asegura su concavidad, ya que en ocasiones pueden pasar por debajo de la línea del azar y mostrar rendimientos peores al de un predictor aleatorio. La concavidad de una curva \\(ROC\\) puede determinarse por métricas como el ratio de probabilidad negativa (\\(NLR = (1 - ROC(t))/(1 - t)\\)). El \\(NLR\\) se corresponde con la pendiente de una línea recta que pasa por un punto de la curva hasta el punto \\((1,1)\\), por tanto, un \\(NLR\\) decreciente se corresponderá con curvas \\(ROC\\) cóncavas. De esta forma, si se asegura la concavidad en la región de alta sensibilidad, o el \\(NLR\\) es decreciente en dicha zona, un nuevo límite inferior puede ser definido. Este nuevo límite más ajustado se define por el triángulo de puntos \\((FPR_0, TPR_0), (1, TPR_0)\\) y \\((1,1)\\), que desarrollado se puede expresar de la siguiente forma: \\[\\begin{equation} \\dfrac{1}{2}(1 - FPR_0)(1 - TPR_0) \\le A \\le (1-FPR_0)(1 - TPR_0) \\tag{5.10} \\end{equation}\\] Finalmente, las curvas \\(ROC\\) pueden presentar ganchos (regiones donde no la curva \\(ROC\\) no es cóncava) en el extremo superior de la región de interés, en estas situaciones el límite inferior definido en (5.9) tampoco se ajusta a la curva. De esta forma, si existe un punto en la región de interés que cumpla \\(NLR(t) &gt; \\text{max}\\ \\{1, NLR_0\\}\\), no se podrá encontrar un límite inferior que se ajuste y por tanto: \\[\\begin{equation} 0 \\le A \\le (1-FPR_0)(1 - TPR_0) \\tag{5.11} \\end{equation}\\] Conociendo todos los casos posibles, y aplicando la transformación descrita por McClish (5.2) se obtiene el \\(FpAUC\\). De forma similar a los casos anteriores, el \\(FpAUC\\) se calculará para contrastarlo con el resto. Al igual que el \\(NpAUC\\), este índice no se encuentra implementado en ningún paquete conocido, por lo que para facilitar su aplicación se ha implementado en el paquete ROCnGO. Para realizar los cálculos sobre el conjunto de datos, se utilizará la función ROCnGO::fp_auc: fpauc_sn_diagnostic &lt;- map_dbl( diagnostic_dataset, \\(gene) { fp_auc( predictor = gene, response = roc_data$disease, lower_tpr = 0.9 ) }, .progress = TRUE ) fpauc_sn_prognostic &lt;- map_dbl( prognostic_dataset, \\(gene) { fp_auc( predictor = gene, response = disease$prognostic, lower_tpr = 0.9 ) }, .progress = TRUE ) 5.4 Comparación de índices Hasta ahora, para identificar posibles biomarcadores de diagnóstico y pronóstico se han utilizado distintos índices en condiciones de alta sensibilidad y especificidad. Sin embargo, como se ha explicado previamente, cada índice presenta una serie de ventajas y desventajas. Por consiguiente, para evaluar cual de todos los índices presenta un mejor rendimiento para seleccionar clasificadores, se compararán cada uno de sus resultados. 5.4.1 Agrupar por condiciones Para facilitar su acceso, los resultados se agruparán en función de las condiciones que se han medido (alta sensibilidad o especificidad) y su finalidad (diagnóstico o pronóstico). indexes_sn_diagnostic &lt;- tibble( identifier = names(auc_diagnostic), auc = auc_diagnostic, pauc = pauc_sn_diagnostic, npauc = npauc_sn_diagnostic, fpauc = fpauc_sn_diagnostic ) indexes_sn_prognostic &lt;- tibble( identifier = names(auc_prognostic), auc = auc_prognostic, pauc = pauc_sn_prognostic, npauc = npauc_sn_prognostic, fpauc = fpauc_sn_prognostic ) indexes_sp_diagnostic &lt;- tibble( identifier = names(auc_diagnostic), auc = auc_diagnostic, pauc = pauc_sp_diagnostic, spauc = spauc_sp_diagnostic, tpauc = tpauc_sp_diagnostic ) indexes_sp_prognostic &lt;- tibble( identifier = names(auc_prognostic), auc = auc_prognostic, pauc = pauc_sp_prognostic, spauc = spauc_sp_prognostic, tpauc = tpauc_sp_prognostic ) 5.4.2 Biomarcadores para diagnóstico 5.4.2.1 Métricas generales Antes de analizar en detalle los distintos índices, es conveniente describir algunas métricas generales. Para ello es posible utilizar la función ROCnGO::summarize_dataset. metrics_diagnostic_tpr &lt;- summarize_dataset( diagnostic_dataset, predictors = NULL, response = roc_data$disease, ratio = &quot;tpr&quot;, threshold = 0.9 ) metrics_diagnostic_fpr &lt;- summarize_dataset( diagnostic_dataset, predictors = NULL, response = roc_data$disease, ratio = &quot;fpr&quot;, threshold = 0.1 ) El conjunto de datos utilizado para diagnóstico contiene la expresión de 2651 genes provenientes de 554 muestras extraídas de pacientes con cáncer de próstata, de las cuales, 52 se corresponden con tejido sano y 502 con tejido canceroso. Los genes de estudio se corresponden con los expresados diferencialmente en experimentos de scRNA-seq. De los 2651 genes seleccionados, 1722 (64.93%) presentan un \\(AUC \\ge 0.5\\). En regiones de alta sensibilidad (\\(TPR \\ge 0.9\\)), de este número 184 presentan curvas \\(ROC\\) cóncavas (10.68% y 6.94% del total), 148 presentan algún tipo de gancho sin atravesar la línea del azar (8.59% y 5.58% del total) y 1390 atraviesan en algún punto dicha línea (80.72% y 52.43% del total). Para regiones de alta especificidad (\\(FPR \\le 0.1\\)), de los predictores con un \\(AUC \\ge 0.5\\), 405 presentan curvas cóncavas (23.51%, un 15.28% del total), 1032 curvas parcialmente adecuadas (59.93%, un 38.92% del total) y 285 contienen algún punto bajo la línea de azar (16.55%, un 10.75% del total). 5.4.2.2 Índices de sensbilidad: \\(NpAUC\\) y \\(FpAUC\\) Tras describir algunas métricas generales de los índices, se explorarán algunas medidas de tendencia central para realizar análisis más detallados. Con estas medidas será posible comprobar, entre otras cosas, el rango de valores que toman los índices. summary(indexes_sn_diagnostic) ## identifier auc pauc npauc ## Length:2651 Min. :0.07099 Min. :0.000000 Min. :0.00000 ## Class :character 1st Qu.:0.44546 1st Qu.:0.003134 1st Qu.:0.03134 ## Mode :character Median :0.56491 Median :0.009447 Median :0.09447 ## Mean :0.55931 Mean :0.010910 Mean :0.10910 ## 3rd Qu.:0.68095 3rd Qu.:0.016338 3rd Qu.:0.16338 ## Max. :0.94369 Max. :0.060244 Max. :0.60244 ## ## fpauc ## Min. :0.5000 ## 1st Qu.:0.6952 ## Median :0.7659 ## Mean :0.7517 ## 3rd Qu.:0.8164 ## Max. :0.9957 ## NA&#39;s :145 Como puede observarse, el \\(pAUC\\) toma valores inferiores a \\(0.5\\), el \\(NpAUC\\) toma valores tanto valores inferiores como superiores a dicho valor y finalmente el \\(FpAUC\\) solo presenta valores superiores. A simple vista, se puede observar como el \\(pAUC\\) se convierte en un métrica de difícil interpretación, al contrario que el \\(NpAUC\\) y \\(FpAUC\\) que tienen límites definidos. Por otra parte, aunque tanto el \\(NpAUC\\) como el \\(FpAUC\\) están comprendidos por debajo de \\(1\\) por su límite superior, no presentan el mismo límite inferior (secciones 5.3.3.1 y 5.3.3.2). Para ilustrar esta situación se utilizará el gen ENSG00000169347, el clasificador de mayor \\(FpAUC\\) en la región de interés. Sus métricas pueden ser rápidamente visualizadas utilizando la función ROCnGO::summarize_predictor. summarize_predictor(roc_data, ENSG00000169347, disease, &quot;tpr&quot;, 0.9) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation auc pauc np_auc fp_auc curve_shape 0.4502184 0.0134041 0.1340408 0.9957314 Concave El clasificador toma aproximadamente el valor máximo para el \\(FpAUC\\), sin embargo, presenta valores reducidos de \\(AUC\\), \\(pAUC\\) e incluso \\(NpAUC\\). Para explicar estos resultados, la curva \\(ROC\\) del clasificador será representada con la función ROCnGO::plot_roc_curve. Además, para facilitar la explicación, también se representará el límite inferior del \\(NpAUC\\). plot_roc_curve(roc_data, response = disease, predictor = ENSG00000169347) + add_chance_line() + add_tpr_threshold_line(0.9) + add_npauc_normalized_lower_bound( roc_data, response = disease, predictor = ENSG00000169347, threshold = 0.9 ) Como se puede observar, el límite inferior del \\(NpAUC\\) se corresponde con la mitad del área de la banda \\((TPR_0, 1)\\). Dado que la curva \\(ROC\\) queda descrita por debajo de esta área, el \\(NpAUC\\) toma valores inferiores a \\(0.5\\) y en consecuencia dificultando su interpretación. Este no es el caso del límite inferior definido por el \\(FpAUC\\), el cual se ajusta a la forma de la curva. Para visualizarlo de forma detalla, se graficará la curva \\(ROC\\) en la región de alta sensibilidad utilizando la función ROCnGO::plot_partial_roc_curve. plot_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000169347, ratio = &quot;tpr&quot;, threshold = 0.9 ) + add_chance_line() + add_tpr_threshold_line(0.9) + add_fpauc_concave_lower_bound( data = roc_data, response = disease, predictor = ENSG00000169347, threshold = 0.9 ) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation Ampliando la figura en la región de interés, se observa como el límite inferior del \\(FpAUC\\) se ajusta a la región definida por la curva \\(ROC\\), en lugar de a toda la banda \\((TPR_0, 1)\\). Así, el \\(FpAUC\\) toma valores mayores a \\(0.5\\), siendo una métrica más interpretable. Este punto puede contrastarse con ENSG00000105707, el predictor de mayor valor para \\(NpAUC\\). summarize_predictor(roc_data, ENSG00000105707, disease, &quot;tpr&quot;, 0.9) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation auc pauc np_auc fp_auc curve_shape 0.9436868 0.0602436 0.6024364 0.8642639 Hook under chance plot_roc_curve(roc_data, response = disease, predictor = ENSG00000105707) + add_chance_line() + add_tpr_threshold_line(0.9) + add_npauc_normalized_lower_bound( roc_data, response = disease, predictor = ENSG00000105707, threshold = 0.9 ) plot_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000105707, ratio = &quot;tpr&quot;, threshold = 0.9 ) + add_chance_line() + add_tpr_threshold_line(0.9) En este caso, la mayor parte de la curva \\(ROC\\) está contenida por encima del límite definido por \\(NpAUC\\). Esto confirma el razonamiento anterior, ya que se obtienen valores superiores a \\(0.5\\). Por otra parte, el \\(FpAUC\\) no puede definir ningún límite inferior puesto que la curva presenta un gancho bajo la línea de azar en el extremo superior. A pesar de ello, el \\(FpAUC\\) considera esta posibilidad por lo que sigue devolviendo valores interpretables. Otra característica de interés de los índices es su capacidad para distinguir predictores con el mismo \\(pAUC\\) y curvas \\(ROC\\) que se cruzan. De todo el conjunto de datos, 633 predictores presentan un \\(pAUC\\) idéntico a otro, formando 246 grupos de \\(pAUC\\) iguales. Para evaluar el rendimiento de los índices en este contexto se utilizarán los genes ENSG00000065361y ENSG00000130653, aquellos con el mayor valor de \\(pAUC\\) entre los grupos formados. bind_rows( &quot;ENSG00000065361&quot; = summarize_predictor( roc_data, ENSG00000065361, disease, &quot;tpr&quot;, 0.9 ), &quot;ENSG00000130653&quot; = summarize_predictor( roc_data, ENSG00000130653, disease, &quot;tpr&quot;, 0.9 ), .id = &quot;Identifier&quot; ) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation ## ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation Identifier auc pauc np_auc fp_auc curve_shape ENSG00000065361 0.7715676 0.0274287 0.2742875 0.8565737 Hook under chance ENSG00000130653 0.7384692 0.0274287 0.2742875 0.8351422 Partially proper plot_roc_curve( roc_data, response = disease, predictor = ENSG00000065361 ) + add_roc_curve( roc_data, response = disease, predictor = ENSG00000130653 ) + add_chance_line() + add_threshold_line(0.9, &quot;tpr&quot;) Ambos predictores presentan \\(AUC\\) relativamente altos y sus curvas se cruzan en diversos puntos dentro de la región de alta sensibilidad. Dado que el \\(NpAUC\\) simplemente realiza una normalización utilizando la banda de alta sensibilidad (5.7), la métrica no es capaz de seleccionar un predictor mejor, dando el mismo valor para ambas (\\(NpAUC = 0.2742875\\)). Por otra parte, el \\(FpAUC\\) adapta sus límites a la forma de la curva \\(ROC\\) por ello es capaz de seleccionar al de mejor rendimiento, ENSG00000065361. Siguiendo este ejemplo, se deduce que el \\(FpAUC\\) presenta una mayor capacidad de discriminación entre predictores con igual \\(pAUC\\), lo cual puede contrastarse con todo el conjunto de datos. metrics_diagnostic_tpr$data %&gt;% filter(pauc != 0) %&gt;% group_by(pauc) %&gt;% filter(n() &gt; 1) %&gt;% mutate( npauc_equal = all( map_lgl(np_auc, \\(x) near(x, np_auc[[1]])) ), fpauc_equal = all( map_lgl(fp_auc, \\(x) near(x, fp_auc[[1]])) ) ) %&gt;% summarize( npauc_equal = all(npauc_equal), fpauc_equal = all(fpauc_equal) ) %&gt;% summarize( npauc_equal = sum(npauc_equal), fpauc_equal = sum(fpauc_equal) ) %&gt;% mutate( npauc_distintct = 246 - npauc_equal, fpauc_distintct = 246 - fpauc_equal, ) %&gt;% relocate( sort(names(.)) ) fpauc_distintct fpauc_equal npauc_distintct npauc_equal 47 199 0 246 De los 246 grupos formados, el \\(NpAUC\\) no es capaz de desempatar en ningún grupo, mientras que el \\(FpAUC\\) es capaz de seleccionar un mejor clasificador en 47 de ellos. Estos cálculos sobre todo el conjunto de datos refuerzan la afirmación de que el \\(FpAUC\\) tiene una mejor capacidad de discriminación que el \\(NpAUC\\). 5.4.2.3 Índices de especificidad: \\(SpAUC\\) y \\(TpAUC\\) Al igual que con los índices de sensibilidad, en primer lugar, se explorarán algunas métricas de tendencia central. summary(indexes_sp_diagnostic) ## identifier auc pauc spauc ## Length:2651 Min. :0.07099 Min. :0.000000 Min. :0.5000 ## Class :character 1st Qu.:0.44546 1st Qu.:0.004635 1st Qu.:0.5278 ## Mode :character Median :0.56491 Median :0.011952 Median :0.5645 ## Mean :0.55931 Mean :0.015553 Mean :0.5813 ## 3rd Qu.:0.68095 3rd Qu.:0.023314 3rd Qu.:0.6213 ## Max. :0.94369 Max. :0.074939 Max. :0.8681 ## NA&#39;s :711 ## tpauc ## Min. :0.0000 ## 1st Qu.:0.7347 ## Median :0.7841 ## Mean :0.7763 ## 3rd Qu.:0.8312 ## Max. :1.0000 ## Observando las métricas el \\(pAUC\\) solo toma valores inferiores a \\(0.5\\) lo cual dificulta su interpretabilidad, a diferencia del \\(SpAUC\\) y \\(TpAUC\\) que pueden tomar valores superiores. Cabe destacar que el \\(TpAUC\\) toma valores iguales a 0 cuando teóricamente debería estar comprendido en \\((0.5, 1)\\). indexes_sp_diagnostic %&gt;% filter(tpauc == 0) identifier auc pauc spauc tpauc ENSG00000169116 0.1625038 0 NA 0 ENSG00000135378 0.1314358 0 NA 0 ENSG00000148985 0.5433650 0 NA 0 ENSG00000171867 0.1755287 0 NA 0 ENSG00000085662 0.1333895 0 NA 0 ENSG00000167711 0.2537542 0 NA 0 ENSG00000101856 0.0867300 0 NA 0 ENSG00000185432 0.1069951 0 NA 0 ENSG00000121691 0.2978854 0 NA 0 ENSG00000148344 0.3502145 0 NA 0 ENSG00000091138 0.2779651 0 NA 0 ENSG00000186526 0.4682616 0 NA 0 ENSG00000156642 0.1963684 0 NA 0 ENSG00000170954 0.2587726 0 NA 0 Una exploración de los datos muestra como estos valores del \\(TpAUC\\) se corresponden con valores de \\(pAUC\\) iguales a \\(0\\), lo cual se puede comprobar de forma gráfica representando algunos de ellos. plot_roc_curve( roc_data, response = disease, predictor = ENSG00000169116 ) + add_roc_curve( roc_data, response = disease, predictor = ENSG00000135378 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) Dado que las curvas de ambos predictores toman valores de \\(TPR = 0\\), no hay un area definida debajo de la curva. Ampliando la imagen esto puede observarse con mayor claridad. plot_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000169116, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000135378, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) Tras comprobar el origen de los valores atípicos, es posible recalcular las métricas filtrando los valores de \\(pAUC = 0\\). De esta forma, \\(TpAUC\\) y \\(SpAUC\\) se encuentran limitados por encima de \\(0.5\\) convirtiéndose en métricas fácilmente interpretables. summary(indexes_sp_diagnostic %&gt;% filter(pauc != 0)) ## identifier auc pauc spauc ## Length:2637 Min. :0.07099 Min. :7.660e-06 Min. :0.5000 ## Class :character 1st Qu.:0.44622 1st Qu.:4.766e-03 1st Qu.:0.5278 ## Mode :character Median :0.56624 Median :1.198e-02 Median :0.5645 ## Mean :0.56098 Mean :1.564e-02 Mean :0.5813 ## 3rd Qu.:0.68162 3rd Qu.:2.337e-02 3rd Qu.:0.6213 ## Max. :0.94369 Max. :7.494e-02 Max. :0.8681 ## NA&#39;s :697 ## tpauc ## Min. :0.5000 ## 1st Qu.:0.7354 ## Median :0.7846 ## Mean :0.7804 ## 3rd Qu.:0.8314 ## Max. :1.0000 ## A pesar de tener buena interpretabilidad, el \\(SpAUC\\) presenta valores de NA. Como se ha explicado anteriormente, el \\(SpAUC\\) tiene su límite definido con el trapecio de puntos \\((FPR_1, 0), (FPR_2, 0), (FPR_1, FPR_1)\\) y \\((FPR_2, FPR_2)\\), o en otras palabras, el que coincide con la línea del azar. Este límite no se ajusta a curvas definidas por debajo de la línea (sección 5.3.2.1), por esta razón la función devuelve estos valores. Esto es posible comprobarlo gráficamente con el predictor ENSG00000181754, un predictor que aun presentan una forma cóncava en la región de interés pasa por debajo de la línea del azar. summarize_predictor( roc_data, ENSG00000181754, disease, &quot;fpr&quot;, 0.1 ) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation auc pauc sp_auc tp_auc curve_shape 0.4311408 0.0049425 NA 0.8215741 Concave plot_roc_curve( roc_data, response = disease, predictor = ENSG00000181754 ) + add_spauc_lower_bound( roc_data, response = disease, predictor = ENSG00000181754, lower_threshold = 0, upper_threshold = 0.1 ) + add_tpauc_concave_lower_bound( roc_data, response = disease, predictor = ENSG00000181754, lower_threshold = 0, upper_threshold = 0.1 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Como se observa en la figura, el límite inferior del \\(SpAUC\\) se encuentra definido por encima de la curva \\(ROC\\), por otra parte el límite del \\(TpAUC\\) se adecua a la región y forma de la curva. Para contrastar este ajuste es posible seleccionar otro predictor con una forma de curva distinta, por ejemplo, ENSG00000111667. summarize_predictor( roc_data, ENSG00000111667, disease, &quot;fpr&quot;, 0.1 ) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation auc pauc sp_auc tp_auc curve_shape 0.413768 0.0049954 NA 0.7985348 Hook under chance plot_roc_curve( roc_data, response = disease, predictor = ENSG00000111667 ) + add_spauc_lower_bound( roc_data, response = disease, predictor = ENSG00000111667, lower_threshold = 0, upper_threshold = 0.1 ) + add_tpauc_under_chance_lower_bound( roc_data, response = disease, predictor = ENSG00000111667, lower_threshold = 0, upper_threshold = 0.1 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation En este caso, la curva \\(ROC\\) queda definida por debajo de la línea de azar y el \\(TpAUC\\) no puede establecer un área mínima, por lo que establece el límite inferior a \\(0\\). Por otra parte, el límite inferior del \\(SpAUC\\) no se adecua y no puede ser calculado. Con estas observaciones, se deduce que tanto el \\(SpAUC\\) y \\(TpAUC\\) son métricas interpretables cuando se trabaja con curvas \\(ROC\\) adecuadas al quedar comprendidas entre \\(0.5\\) y \\(1\\). Sin embargo, el \\(TpAUC\\) se convierte en una métrica más adecuada en condiciones generales, ya que sus límites se ajustan a la forma de la curva \\(ROC\\) a diferencia del \\(SpAUC\\), imposibilitando su uso en curvas comprendidas debajo de la línea del azar. Una vez considerada la interpretabilidad de las métricas, se puede contrastar su capacidad para distinguir entre predictores con curvas que se cruzan e igual \\(pAUC\\). Del conjunto de datos, 374 predictores presentan un \\(pAUC\\) igual a otro, formando 174 grupos de \\(pAUC\\) iguales. Para evaluar el rendimiento de los índices utilizaremos los predictores ENSG00000175336 y ENSG00000169733, aquellos que presentan el mayor valor de \\(pAUC\\) en este subgrupo de predictores. bind_rows( &quot;ENSG00000175336 &quot; = summarize_predictor( roc_data, ENSG00000175336, disease, &quot;fpr&quot;, 0.1 ), &quot;ENSG00000169733&quot; = summarize_predictor( roc_data, ENSG00000169733, disease, &quot;fpr&quot;, 0.1 ), .id = &quot;Identifier&quot; ) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation ## ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Identifier auc pauc sp_auc tp_auc curve_shape ENSG00000175336 0.8286086 0.0475329 0.7238576 0.8695316 Partially Proper ENSG00000169733 0.8126724 0.0475329 0.7238576 0.9123511 Partially Proper plot_roc_curve( roc_data, response = disease, predictor = ENSG00000175336 ) + add_roc_curve( roc_data, response = disease, predictor = ENSG00000169733 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) Comprobando sus \\(AUC\\), ambos predictores presentan un buen rendimiento global. El \\(SpAUC\\) se mantiene igual para ambos predictores (\\(SpAUC = 0.7238576\\)) mientras que el \\(TpAUC\\) toma valores distintos, lo que permite identificar el predictor de mejor rendimiento. Esta diferencia puede deberse a que el \\(TpAUC\\) adapta sus límites a los puntos de la curva (sección 5.3.2.2), a diferencia del \\(SpAUC\\) que los mantienen iguales. Esta capacidad de discriminación entre predictores se puede contrastar con el resto del conjunto de datos: metrics_diagnostic_fpr$data %&gt;% filter(pauc != 0) %&gt;% group_by(pauc) %&gt;% filter(n() &gt; 1) %&gt;% mutate( spauc_equal = all( map_lgl(sp_auc, \\(x) near(x, sp_auc[[1]])) ), tpauc_equal = all( map_lgl(tp_auc, \\(x) near(x, tp_auc[[1]])) ) ) %&gt;% summarize( spauc_equal = all(spauc_equal), tpauc_equal = all(tpauc_equal) ) %&gt;% dplyr::count(spauc_equal, tpauc_equal) spauc_equal tpauc_equal n TRUE FALSE 93 TRUE TRUE 2 NA FALSE 45 NA TRUE 34 De los 374 predictores con un \\(pAUC &gt; 0\\) y al menos igual a otro predictor (174 grupos), se observa como el \\(SpAUC\\) no es capaz de diferenciar el predictor de mayor rendimiento en ningún caso. Además, el índice solo toma valores para 95 de los grupos, no estando definido para el resto. Por otro lado, el \\(TpAUC\\) es capaz de distinguir un mejor predictor en 138 de los grupos, siendo incapaz de hacerlo solamente en 36 de ellos. Los resultados sobre el conjunto de datos refuerzan que ambos índices son fácilmente interpretables. Sin embargo, muestran que el \\(SpAUC\\) no es aplicable cuando la curva \\(ROC\\) pasa por debajo de la línea del azar. Además, el \\(SpAUC\\) no es capaz de discriminar entre ciertos predictores. Por otra parte, el \\(TpAUC\\) resulta más útil en la práctica al poder aplicarse a cualquier tipo de curva y ser capaz de discriminar entre predictores con igual \\(pAUC\\). 5.4.3 Biomarcadores para pronóstico 5.4.3.1 Métricas generales En esta sección se repetirán los procedimientos realizados previamente, pero en esta ocasión serán aplicados a marcadores de pronóstico. metric_prognostic_tpr &lt;- summarize_dataset( prognostic_dataset, predictors = NULL, response = disease$prognostic, ratio = &quot;tpr&quot;, threshold = 0.9 ) metric_prognostic_fpr &lt;- summarize_dataset( prognostic_dataset, predictors = NULL, response = disease$prognostic, ratio = &quot;fpr&quot;, threshold = 0.1 ) El conjunto de datos utilizado para pronóstico contiene la expresión de 2652 genes provenientes de 502 muestras extraídas de pacientes con la enfermedad. Los genes de estudio se corresponde con los diferencialmente expresados en experimentos de scRNA-seq. De los 2651 genes seleccionados, 1015 (38.27%) presentan un \\(AUC \\ge 0.5\\). En regiones de alta sensibilidad (\\(TPR \\ge 0.9\\)), de este número 173 presentan curvas \\(ROC\\) cóncavas (17.04% y 6.52% del total), 296 presentan algún tipo de gancho sin llegar a atravesar la línea del azar (29.16% y 11.16% del total) y 546 atraviesan en algún punto dicha línea (52.43% y 20.59% del total). Para regiones de alta especificidad (\\(FPR \\le 0.1\\)), de los predictores con un \\(AUC \\ge 0.5\\), 127 presentan curvas cóncavas (12.51%, un 4.79% del total), 376 curvas parcialmente adecuadas (37.04%, un 14.18% del total) y 511 contienen algún punto bajo la línea de azar (50.34%, un 19.27% del total). 5.4.3.2 Índices de sensibilidad: \\(NpAUC\\) y \\(FpAUC\\) De forma similar al procedimiento en condiciones de diagnóstico, se explorarán algunas medidas de tendencia central. summary(metric_prognostic_tpr$data) ## identifier auc pauc np_auc ## Length:2651 Min. :0.2485 Min. :0.000000 Min. :0.00000 ## Class :character 1st Qu.:0.4289 1st Qu.:0.003098 1st Qu.:0.03098 ## Mode :character Median :0.4767 Median :0.004921 Median :0.04921 ## Mean :0.4778 Mean :0.005477 Mean :0.05477 ## 3rd Qu.:0.5249 3rd Qu.:0.007376 3rd Qu.:0.07376 ## Max. :0.7377 Max. :0.024389 Max. :0.24389 ## ## fp_auc curve_shape ## Min. :0.5000 Length:2651 ## 1st Qu.:0.6950 Class :character ## Median :0.7434 Mode :character ## Mean :0.7354 ## 3rd Qu.:0.7848 ## Max. :0.9758 ## NA&#39;s :1 En este contexto, tanto el \\(pAUC\\) como el \\(NpAUC\\) toman valores inferiores a \\(0.5\\) mientras que el \\(FpAUC\\) toma superiores. Estos resultados probablemente se deban a los límites definidos por el \\(NpAUC\\) y \\(FpAUC\\). El \\(NpAUC\\) define su límite inferior como la mitad del área de la banda \\((TPR_0, 1)\\) (5.7), en consecuencia, una curva \\(ROC\\) contenida por este límite resultará en valores de \\(NpAUC\\) inferiores a \\(0.5\\). Para visualizarlo, se escogerá el predictor ENSG00000185615 que posee el mayor valor de \\(NpAUC\\) en los datos. summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000185615, prognostic, &quot;tpr&quot;, 0.9 ) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation auc pauc np_auc fp_auc curve_shape 0.7143536 0.0243888 0.2438877 0.7743255 Partially proper plot_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000185615 ) + add_chance_line() + add_tpr_threshold_line(0.9) + add_fpauc_partially_proper_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000185615, threshold = 0.9 ) + add_npauc_normalized_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000185615, threshold = 0.9 ) Como se observa en la figura, la curva \\(ROC\\) queda definida por debajo del límite definido por \\(NpAUC\\) pero por encima del definido por \\(FpAUC\\). De esta forma, se confirma que el \\(FpAUC\\) presenta mejor interpretabilidad, además de ser aplicable independientemente de la forma de la curva. Además de su interpretabilidad, es interesante evaluar la capacidad para distinguir predictores con igual \\(pAUC\\) y cuyas curvas se cruzan en algún punto en la región de interés. De todo el conjunto de datos, 241 predictores presentan un \\(pAUC\\) idéntico a al menos otro, formando 114 grupos en función de esta métrica. Para evaluar el rendimiento de los índices se utilizarán los predictores ENSG00000272333 y ENSG00000096070, aquellos de mayor \\(pAUC\\) en los grupos formados. bind_rows( &quot;ENSG00000272333&quot; = summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000272333, prognostic, &quot;tpr&quot;, 0.9 ), &quot;ENSG00000096070&quot; = summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000096070, prognostic, &quot;tpr&quot;, 0.9 ), .id = &quot;Identifier&quot; ) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation ## ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation Identifier auc pauc np_auc fp_auc curve_shape ENSG00000272333 0.5947269 0.0131597 0.1315975 0.7782804 Partially proper ENSG00000096070 0.5004503 0.0131597 0.1315975 0.8087762 Concave plot_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000272333 ) + add_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000096070 ) + add_chance_line() + add_threshold_line(0.9, &quot;tpr&quot;) En este caso, los predictores no presentan un buen rendimiento global, a diferencia de en la región de interés. En esta región ambas curvas se cruzan en varios puntos y mientras que el \\(NpAUC\\) no es capaz de distinguir el predictor de mayor rendimiento (\\(NpAUC = 0.13159748\\)), el \\(FpAUC\\) identifica que ENSG00000096070 (\\(FpAUC = 0.8087762\\)) rinde mejor que ENSG00000272333 (\\(FpAUC = 0.7782804\\)). De forma similar a las condiciones de diagnóstico, dado que el \\(FpAUC\\) adapta sus límites a la forma y puntos de la curva, puede distinguir entre predictores con igual \\(pAUC\\) cuyas curvas se cruzan. Esta capacidad de discriminación puede contrastarse con el resto del conjunto de datos. metric_prognostic_tpr$data %&gt;% filter(pauc != 0) %&gt;% group_by(pauc) %&gt;% filter(n() &gt; 1) %&gt;% mutate( npauc_equal = all( map_lgl(np_auc, \\(x) near(x, np_auc[[1]])) ), fpauc_equal = all( map_lgl(fp_auc, \\(x) near(x, fp_auc[[1]])) ) ) %&gt;% summarize( npauc_equal = all(npauc_equal), fpauc_equal = all(fpauc_equal) ) %&gt;% dplyr::count(npauc_equal, fpauc_equal) npauc_equal fpauc_equal n TRUE FALSE 38 TRUE TRUE 76 El \\(FpAUC\\) es capaz de desempatar entre los predictores en 38 de los 114 grupos formados, mientras que el \\(NpAUC\\) no es capaz de hacerlo en ninguno de ellos. 5.4.3.3 Índices de especificidad: \\(SpAUC\\) y \\(TpAUC\\) Igual que en los casos anteriores, para realizar la evaluación de los índices se explorarán algunas métricas generales en primer lugar. summary(metric_prognostic_fpr$data) ## identifier auc pauc sp_auc ## Length:2651 Min. :0.2485 Min. :0.0002866 Min. :0.5000 ## Class :character 1st Qu.:0.4289 1st Qu.:0.0036109 1st Qu.:0.5065 ## Mode :character Median :0.4767 Median :0.0054696 Median :0.5148 ## Mean :0.4778 Mean :0.0063296 Mean :0.5196 ## 3rd Qu.:0.5249 3rd Qu.:0.0082330 3rd Qu.:0.5276 ## Max. :0.7377 Max. :0.0277573 Max. :0.6198 ## NA&#39;s :1167 ## tp_auc curve_shape ## Min. :0.5000 Length:2651 ## 1st Qu.:0.7088 Class :character ## Median :0.7492 Mode :character ## Mean :0.7443 ## 3rd Qu.:0.7855 ## Max. :0.9322 ## De nuevo, el \\(pAUC\\) solo toma valores inferiores a \\(0.5\\) a diferencia del \\(SpAUC\\) y \\(TpAUC\\) que toman valores superiores. Además, el \\(SpAUC\\) toma valores de NA, los cuales se corresponden para casos donde el límite inferior (5.1) no se cumple, como se ha visto previamente. A diferencia del escenario anterior, el \\(TpAUC\\) no toma valores atípicos por debajo de \\(0.5\\), esto se debe a que no hay predictores con \\(pAUC = 0\\). Para contrastar la interpretabilidad de ambos índices se utilizará arbitrariamente el predictor ENSG00000110013, que no presenta valor para el \\(SpAUC\\) y uno relativamente alto para el \\(TpAUC\\). summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000110013, prognostic, &quot;fpr&quot;, 0.1 ) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation auc pauc sp_auc tp_auc curve_shape 0.3827888 0.0008352 NA 0.9322034 Hook under chance plot_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000110013 ) + add_spauc_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000110013, lower_threshold = 0, upper_threshold = 0.1 ) + add_tpauc_under_chance_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000110013, lower_threshold = 0, upper_threshold = 0.1 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Como se observa en la figura, la curva \\(ROC\\) se encuentra contenida bajo el límite inferior de \\(SpAUC\\) y por tanto obteniendo un valor de NA. Por otra parte, el límite de \\(TpAUC\\) (\\(0\\), dado que \\(TPR = 0\\) para toda la región) se ajusta a la forma de la curva y por tanto puede calcularse. Al igual que en los casos anteriores, de forma general \\(SpAUC\\) y \\(TpAUC\\) son métricas interpretables dado que se comprenden entre valores de \\(0.5\\) y \\(1\\). Sin embargo, el \\(SpAUC\\) define límites que no se ajustan a ciertas curvas y por tanto imposibilitando su aplicación, mientras que el \\(TpAUC\\) se ajusta a la forma de la curva, pudiéndose aplicar a cualquiera y por tanto haciéndola una métrica más idónea. Una vez considerada la interpretabilidad de ambas métricas, se contrastará su capacidad para discriminar predictores con curvas que se cruzan y de igual \\(pAUC\\). Del conjunto de datos, 917 predictores presentan un \\(pAUC\\) igual al menos a otro, formándose 407 grupos en función de esta métrica. Para estudiar la capacidad de discriminación, se utilizarán los predictores ENSG00000177943 y ENSG00000136783, aquellos de mayor \\(pAUC\\) entre los grupos formados. bind_rows( &quot;ENSG00000177943&quot; = summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000177943, prognostic, &quot;fpr&quot;, 0.1 ), &quot;ENSG00000136783&quot; = summarize_predictor( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), ENSG00000136783, prognostic, &quot;fpr&quot;, 0.1 ), .id = &quot;Identifier&quot; ) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation ## ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Identifier auc pauc sp_auc tp_auc curve_shape ENSG00000177943 0.6587407 0.0172194 0.5643124 0.8111201 Partially Proper ENSG00000136783 0.6306722 0.0172194 0.5643124 0.7711047 Partially Proper plot_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000177943 ) + add_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000136783 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) Ambos predictores presentan un rendimiento ligeramente mejor que un clasificador aleatorio a nivel global, pero en la región de interés presentan un rendimiento mucho mejor. Los predictores presentan el mismo \\(SpAUC\\) (\\(0.5643124\\)), a diferencia del \\(TpAUC\\) que toma valores distintos e indica que ENSG00000177943 presenta un mejor rendimiento. plot_partial_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000177943, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_partial_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000136783, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_tpauc_partially_proper_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000177943, upper_threshold = 0.1, lower_threshold = 0 ) + add_tpauc_partially_proper_lower_bound( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000136783, upper_threshold = 0.1, lower_threshold = 0 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation ## ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Para este caso, ambos predictores poseen el mismo límite inferior para \\(TpAUC\\), sin embargo sus límites superiores será distintos dado que poseen distinto \\(TPR_2\\), (5.4). Por este motivo, el índice toma valores distintos estableciendo que el predictor ENSG00000177943 (\\(TpAUC = 0.8111201\\)) rinde mejor que ENSG00000136783 (\\(TpAUC = 0.7711047\\)). Esta capacidad de discriminación se puede contrastar en todo el conjunto de datos. metric_prognostic_fpr$data %&gt;% filter(pauc != 0) %&gt;% group_by(pauc) %&gt;% filter(n() &gt; 1) %&gt;% mutate( spauc_equal = all( map_lgl(sp_auc, \\(x) near(x, sp_auc[[1]])) ), tpauc_equal = all( map_lgl(tp_auc, \\(x) near(x, tp_auc[[1]])) ) ) %&gt;% summarize( spauc_equal = all(spauc_equal), tpauc_equal = all(tpauc_equal) ) %&gt;% dplyr::count(spauc_equal, tpauc_equal) spauc_equal tpauc_equal n TRUE FALSE 184 TRUE TRUE 28 NA FALSE 138 NA TRUE 56 De los 407 grupos de grupos formados, el \\(SpAUC\\) no es capaz de diferenciar un biomarcador que rinda mejor en ninguno de ellos. Además, no es capaz de aplicarse debido a la forma de la curva en 194 de ellos. Por otra parte el \\(TpAUC\\) es capaz de diferenciar un mejor predictor en 323 grupos de los 407 totales. Este hecho refuerza que el \\(TpAUC\\) es una mejor métrica a la hora de evaluar el rendimiento de un predictor, al ser aplicable a cualquier tipo de curva y discriminar entre predictores con igual \\(pAUC\\), a diferencia del \\(SpAUC\\). 5.5 Resultados 5.5.1 Rendimiento de métricas Tras haber contrastado distintas transformaciones del \\(pAUC\\) en condiciones de alta sensibilidad y especificidad, se observa como el \\(TpAUC\\) y \\(FpAUC\\) presentan un mejor rendimiento a la hora de seleccionar predictores relevantes. Estos índices solventan limitaciones descritas por el propio \\(pAUC\\) y otras transformaciones derivadas, como el \\(SpAUC\\) y el \\(NpAUC\\), lo que hace que se conviertan en métricas más idóneas en la práctica. En primer lugar, ambas métricas presentan límites inferiores y superiores que se ajustan a las curvas \\(ROC\\) de un predictor, independientemente de su forma. En segundo lugar, son capaces de discriminar entre predictores que presentan un mismo \\(pAUC\\) y cuyas curvas \\(ROC\\) se cruzan en la región de interés, algo que no había sido posible hasta ahora. Finalmente, pero no menos importante, comprenden sus valores entre \\(0.5\\) y \\(1\\), lo cual facilita su interpretación a la hora de seleccionar predictores. Como se ha comprobado en las secciones anteriores, estas limitaciones son comunes en la práctica por lo que el \\(TpAUC\\) y \\(FpAUC\\) presentan un valor añadido como métricas de selección de predictores. 5.5.2 Relevancia clínica Aunque teóricamente el \\(TpAUC\\) y \\(FpAUC\\) solventan las limitaciones de otros índices, en la práctica, estas también deben de ser capaces de encontrar biomarcadores clínicamente relevantes. Esta capacidad puede comprobarse con el conjunto de datos generado y predictores ya conocidos para el diagnóstico y estratificación de pacientes en cáncer de próstata. Desde la primera vez que fue descrito, el antígeno específico de próstata (PSA) ha sido utilizado en los planes de diagnóstico y tratamiento de pacientes con cáncer de próstata. Desde su aplicación, la mortalidad y el número de diagnósticos en estados avanzados de la enfermedad se ha reducido, sin embargo, este biomarcador presenta ciertas limitaciones (Wasim, Lee, and Kim 2022). Aunque el PSA es específico del tejido, este puede presentarse en lesiones benignas, es decir, generando falsos positivos. Además, a la hora de realizar una estratificación de riesgo de un paciente requiere de utilizar otras técnicas y métricas adicionales. El nombre de PSA es utilizado en el ámbito clínico, pero en otros ámbitos también es conocido como kallikrein related peptidase 3 (KLK3), una proteasa expresada en las células del tejido. Este biomarcador se encuentra entre los descritos en el conjunto de datos con el identificador ENSG00000142515. inner_join( metrics_diagnostic_tpr$data %&gt;% filter(identifier == &quot;ENSG00000142515&quot;) %&gt;% select(-curve_shape), metrics_diagnostic_fpr$data %&gt;% filter(identifier == &quot;ENSG00000142515&quot;) %&gt;% select(-curve_shape), join_by(identifier, auc), suffix = c(&quot;_sens&quot;, &quot;_spec&quot;) ) identifier auc pauc_sens np_auc fp_auc pauc_spec sp_auc tp_auc ENSG00000142515 0.649479 0.0191005 0.1910052 0.7640208 0.0135228 0.544857 0.7856116 Además de KLK3, entre los datos se pueden encontrar otros biomarcadores de diagnóstico conocidos, como AMACR (ENSG00000242110) y FOLH1 (ENSG00000086205). El rendimiento de estos biomarcadores puede comparase con los diversos índices, para así, contrastarlos en función relevancia clínica. known_markers &lt;- c( &quot;ENSG00000242110&quot;, &quot;ENSG00000086205&quot;, &quot;ENSG00000142515&quot; ) metrics_diagnostic_fpr$data %&gt;% filter(identifier %in% known_markers) identifier auc pauc sp_auc tp_auc curve_shape ENSG00000086205 0.8114848 0.0414879 0.6920416 0.8457328 Partially Proper ENSG00000142515 0.6494790 0.0135228 0.5448570 0.7856116 Partially Proper ENSG00000242110 0.9157217 0.0672311 0.8275320 0.8231707 Concave plot_roc_curve( roc_data, response = disease, predictor = ENSG00000142515 ) + add_roc_curve(roc_data, response = disease, predictor = ENSG00000242110) + add_roc_curve(roc_data, response = disease, predictor = ENSG00000086205) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) Tras representar las curvas \\(ROC\\) de los clasificadores se puede observar como KLK3 no presenta un buen rendimiento a nivel global. Sin embargo, este predictor presenta mejor rendimiento en la región de interés, lo cual puede explicar su uso hasta la fecha. A pesar de ello, como se ha explicado previamente, KLK3 presenta un gran número de falsos positivos, lo cual, explica que otros predictores como FOLH1 y AMACR presentan mejores puntuaciones en la región de interés. plot_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000142515, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000242110, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_partial_roc_curve( roc_data, response = disease, predictor = ENSG00000086205, ratio = &quot;fpr&quot;, threshold = 0.1 ) + add_tpauc_concave_lower_bound( roc_data, response = disease, predictor = ENSG00000242110, upper_threshold = 0.1, lower_threshold = 0 ) + add_tpauc_partially_proper_lower_bound( roc_data, response = disease, predictor = ENSG00000086205, upper_threshold = 0.1, lower_threshold = 0 ) + add_chance_line() + add_threshold_line(0.1, &quot;fpr&quot;) ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation ## ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation Si nos centramos en esta zona, el \\(SpAUC\\) califica al AMACR como el predictor de mejor rendimiento (\\(SpAUC = 0.828\\)), pero además, puntúa relativamente bajo al resto, es decir a KLK3 y FOLH1 (\\(SpAUC = 0.545\\) y \\(SpAUC = 0.692\\)). Por otra parte, el \\(TpAUC\\) califica a FOLH1 como el predictor de mayor rendimiento (\\(TpAUC = 0.846\\)) y al AMACR como valores muy similares (\\(TpAUC = 0.823\\)). Contrastando estos resultados con otros estudios, tanto el AMACR como el FOLH1 se encuentran sobrexpresados en pacientes con la enfermedad (N. Jiang et al. 2013; Haberkorn et al. 2016). Sin embargo, FOLH1 presenta un mayor interés, por además de su uso a nivel de diagnóstico, como diana terapéutica (Sheehan et al. 2022). Esto refuerza la interpretación dada por \\(TpAUC\\), donde tanto AMACR y FOLH1 presentan potencial como clasificadores, y en concreto este último, un rendimiento ligermante superior. Si se selecciona alguno los primeros biomarcadores identificados por el \\(TpAUC\\), puede observarse que se encuentran relacionados con la enfermedad, por ejemplo ESRP2 (ENSG00000103067), al cual estudios recientes lo describen por tener un papel relevante en el desarrollo de la enfermedad (Advani et al. 2023). metrics_diagnostic_fpr$data %&gt;% filter(identifier == &quot;ENSG00000103067&quot;) %&gt;% select(-curve_shape) identifier auc pauc sp_auc tp_auc ENSG00000103067 0.8339335 0.0499464 0.7365598 0.9497378 Por otra parte, KLK3 presenta un rendimiento peor que un clasificador aleatorio para distinguir entre pacientes con una enfermedad más o menos agresiva. inner_join( metric_prognostic_fpr$data %&gt;% filter(identifier == &quot;ENSG00000142515&quot;) %&gt;% select(-curve_shape), metric_prognostic_tpr$data %&gt;% filter(identifier == &quot;ENSG00000142515&quot;) %&gt;% select(-curve_shape), join_by(identifier, auc), suffix = c(&quot;_spec&quot;, &quot;_sens&quot;) ) identifier auc pauc_spec sp_auc tp_auc pauc_sens np_auc fp_auc ENSG00000142515 0.3177106 0.0008106 NA 0.779661 0.0011463 0.0114632 0.6690821 plot_roc_curve( prognostic_dataset %&gt;% mutate(prognostic = disease$prognostic), response = prognostic, predictor = ENSG00000142515 ) + add_chance_line() La curva \\(ROC\\) del predictor queda definida por debajo de la línea de azar, confirmando un rendimiento peor que un clasificador completamente aleatorio. Cabe destacar, que el cálculo de la curva se ha realizado considerando como condición de interés padecer una forma de la enfermedad más agresiva, y por tanto es posible que el KLK3 rinda mejor identificando formas menos agresivas de la enfermedad. Para comprobarlo, es posible invertir la forma de la curva, lo cual resulta equivalente a invertir la condición de interés. inverse_prognostic_dataset &lt;- prognostic_dataset %&gt;% mutate( prognostic = disease$prognostic ) inverse_prognostic_dataset$prognostic &lt;- fct_recode( inverse_prognostic_dataset$prognostic, &quot;1&quot; = &quot;0&quot;, &quot;0&quot; = &quot;1&quot; ) inverse_prognostic_dataset$prognostic &lt;- fct_relevel( inverse_prognostic_dataset$prognostic, &quot;0&quot; ) tpr_metrics &lt;- summarize_predictor( inverse_prognostic_dataset, predictor = ENSG00000142515, response = prognostic, ratio = &quot;tpr&quot;, threshold = 0.9 ) fpr_metrics &lt;- summarize_predictor( inverse_prognostic_dataset, predictor = ENSG00000142515, response = prognostic, ratio = &quot;fpr&quot;, threshold = 0.1 ) inner_join( fpr_metrics, tpr_metrics, join_by(auc), suffix = c(&quot;_spec&quot;, &quot;_sens&quot;) ) %&gt;% mutate( identifier = &quot;ENSG00000142515&quot;, .before = 1 ) %&gt;% select( !starts_with(&quot;curve_shape&quot;) ) ## ℹ Upper threshold 1 already included in points. ## • Skipping upper threshold interpolation ## ## ℹ Lower threshold 0 already included in points. ## • Skipping lower threshold interpolation identifier auc pauc_spec sp_auc tp_auc pauc_sens np_auc fp_auc ENSG00000142515 0.6822894 0.0151036 0.5531767 0.7319498 0.0152133 0.152133 0.7315611 plot_roc_curve( inverse_prognostic_dataset, response = prognostic, predictor = ENSG00000142515 ) + add_chance_line() Al realizar la inversión, las diversas métricas presentan ciertas mejoras a excepción del \\(TpAUC\\) que se ve ligeramente reducido. A pesar de ello, las métricas obtenidas distan de ser ideales para el ámbito clínico. Para realizar un mejor contraste, estas métricas se compararán con otros predictores usados en tests de estratificación de riesgo (Farha and Salami 2022), como por ejemplo: Decipher (Erho et al. 2013) y Oncotype (Klein et al. 2014). decipher &lt;- tibble::tribble( ~name, ~ensemble, &quot;LASP1&quot;, &quot;ENSG00000002834&quot;, &quot;IQGAP3&quot;, &quot;ENSG00000183856&quot;, &quot;NFIB&quot;, &quot;ENSG00000147862&quot;, &quot;S1PR4&quot;, &quot;ENSG00000125910&quot;, &quot;THBS2&quot;, &quot;ENSG00000186340&quot;, &quot;ANO7&quot;, &quot;ENSG00000146205&quot;, &quot;PCDH7&quot;, &quot;ENSG00000169851&quot;, &quot;MYBPC1&quot;, &quot;ENSG00000196091&quot;, &quot;EPPK1&quot;, &quot;ENSG00000261150&quot;, &quot;PBX1&quot;, &quot;ENSG00000185630&quot;, &quot;NUSAP1&quot;, &quot;ENSG00000137804&quot;, &quot;ZWILCH&quot;, &quot;ENSG00000174442&quot;, &quot;UBE2C&quot;, &quot;ENSG00000175063&quot;, &quot;CAMK2N1&quot;, &quot;ENSG00000162545&quot;, &quot;RABGAP1&quot;, &quot;ENSG00000011454&quot;, &quot;TNFRSF19&quot;, &quot;ENSG00000127863&quot; ) oncotype &lt;- tibble::tribble( ~name, ~ensemble, &quot;BGN&quot;, &quot;ENSG00000182492&quot;, &quot;COL1A1&quot;, &quot;ENSG00000108821&quot;, &quot;SFRP4&quot;, &quot;ENSG00000106483&quot;, &quot;FLNC&quot;, &quot;ENSG00000128591&quot;, &quot;GSN&quot;, &quot;ENSG00000148180&quot;, &quot;TPM2&quot;, &quot;ENSG00000198467&quot;, &quot;GSTM2&quot;, &quot;ENSG00000213366&quot;, &quot;TPX2&quot;, &quot;ENSG00000088325&quot;, &quot;LAMB3&quot;, &quot;ENSG00000196878&quot;, &quot;FAM13C&quot;, &quot;ENSG00000148541&quot;, &quot;KLK2&quot;, &quot;ENSG00000167751&quot;, &quot;AZGP1&quot;, &quot;ENSG00000160862&quot;, &quot;SRD5A2&quot;, &quot;ENSG00000277893&quot;, &quot;DUSP1&quot;, &quot;ENSG00000120129&quot;, &quot;FOS&quot;, &quot;ENSG00000170345&quot; ) metric_prognostic_tpr$data %&gt;% arrange(desc(fp_auc)) %&gt;% filter( identifier %in% oncotype$ensemble | identifier %in% decipher$ensemble ) identifier auc pauc np_auc fp_auc curve_shape ENSG00000146205 0.3072628 0.0005371 0.0053713 0.6980676 Hook under chance ENSG00000196091 0.6931794 0.0197331 0.1973307 0.7842261 Partially proper ENSG00000127863 0.5723573 0.0117907 0.1179071 0.7220660 Partially proper ENSG00000167751 0.6340948 0.0112912 0.1129125 0.6776655 Partially proper ENSG00000160862 0.6679767 0.0208958 0.2089577 0.7584779 Partially proper Entre los datos, es posible encontrar biomarcadores utilizados en estos tests, los cuales presentan puntuaciones relativamente bajas, a excepción del \\(FpAUC\\) que las puntúa en mejor medida5. Contrastando estos resultados, se puede observar como el \\(FpAUC\\) es más representativo de los biomarcadores actualmente utilizados en tests de estratificación de riesgos. Es más, entre los predictores con mayor \\(FpAUC\\) se encuentra ENSG00000112210 (RAB23), el cual se encuentra relacionado con la progresión de la enfermedad (Chang et al. 2017). 5.6 Discusión y conclusiones El desarrollo de nuevas tecnologías permite el estudio simultáneo de un gran número de biomarcadores, donde los análisis basados en \\(AUC\\) son habitualmente utilizados. En el ámbito clínico, regiones concretas de las curvas \\(ROC\\) son más relevantes, principalmente para tratar con los costes y consecuencias de diagnósticos erróneos. De esta forma, las métricas que evalúan estas regiones, como el \\(pAUC\\), están ganando mayor interés. A pesar de ello, esta métrica presenta limitaciones para su uso debido a su interpretabilidad, por lo que transformaciones alternativas para trabajar en estas regiones resultan de mayor utilidad. En este trabajo se ha analizado el rendimiento de métricas derivadas del \\(pAUC\\) en regiones de interés, para ello se ha utilizado un conjunto de datos generado con distintas muestras de cáncer de próstata. Las diferentes métricas han sido evaluadas en función de su capacidad para encontrar biomarcadores de diagnóstico y estratificación de riesgo, escenarios donde condiciones de alta especificidad y sensibilidad son requeridas. Entre las métricas descritas, el \\(SpAUC\\) fue la primera transformación del \\(pAUC\\) descrita, la cual permite trabajar en regiones de alta especificidad. Esta métrica es fácilmente interpretable al comprender sus valores entre \\(0.5\\) y \\(1\\), sin embargo, no es aplicable a regiones de la curva \\(ROC\\) descritas por debajo de la línea de azar. Estas regiones son comunes en la práctica, lo cual limita su uso en gran medida. Este problema ha sido resuelto por el \\(TpAUC\\) la cual, además de tomar valores entre \\(0.5\\) y \\(1\\), puede aplicarse a regiones que pasen por debajo de la línea del azar. De forma similar, el \\(NpAUC\\) fue propuesto para trabajar en regiones de alta sensibilidad. Esta métrica puede tomar valores máximos de \\(1\\), pero al no estar limitada por debajo, también puede tomar valores inferiores a \\(0.5\\), lo que dificulta su interpretación y aplicación a ciertos predictores. Estos problemas han sido resueltos por el \\(FpAUC\\) el cual, además de contener sus valores entre \\(0.5\\) y \\(1\\), se puede aplicar independientemente de la forma de la curva. Además de presentar una mejor interpretabilidad, el \\(TpAUC\\) y \\(FpAUC\\) han sido capaces de distinguir entre predictores que presentan el mismo \\(pAUC\\) y cuyas curvas \\(ROC\\) se cruzan, algo que hasta ahora no había sido posible con las anteriores métricas. De esta forma, tanto el \\(TpAUC\\) como el \\(FpAUC\\) poseen una mayor capacidad de discriminación, permitiendo la selección de otros biomarcadores que convencionalmente se habrían descartado. Finalmente, para considerar la relevancia clínica de las métricas, los resultados obtenidos se han contrastado con predictores relevantes en el ámbito clínico. Con respecto a biomarcadores de diagnóstico, el \\(TpAUC\\) otorga puntuaciones similares a los 2 biomarcadores de mayor interés actualmente, a diferencia del \\(SpAUC\\) que penaliza a uno de ellos. En condiciones de estratificación de riesgo, el \\(NpAUC\\) presenta valores muy bajos para predictores que actualmente se utilizan en tests de estratificación de riesgo, a diferencia del \\(FpAUC\\) que les otorga puntuaciones mayores. Estos resultados revelan la utilidad práctica del \\(TpAUC\\) y \\(FpAUC\\) frente al resto. Su facilidad para ser interpretadas y capacidad de discriminar entre biomarcadores altamente específicos o sensibles incentiva su uso en el ámbito clínico, permitiendo la selección de biomarcadores que puedan ayudar en la toma de decisiones. Las curvas \\(ROC\\) de los biomarcadores ENSG00000196091, ENSG00000127863, ENSG00000167751 y ENSG00000160862 fueron invertidas a la hora de realizar los cálculos. Esto se debe a que, en los tests, la expresión reducida de estos biomarcadores está relacionada con un peor pronóstico, en lugar de su sobrexpresión.↩︎ "],["session-info.html", "A Información de la sesión", " A Información de la sesión La información de la sesión de R utilizada durante el trabajo se muestra a continuación: xfun::session_info( packages = c( &quot;Seurat&quot;, &quot;dplyr&quot;, &quot;purrr&quot;, &quot;data.table&quot;, &quot;stringr&quot;, &quot;tibble&quot;, &quot;readr&quot;, &quot;tidyr&quot;, &quot;forcats&quot;, &quot;biomaRt&quot;, &quot;pROC&quot;, &quot;ROCpAI&quot;, &quot;ROCnGO&quot; ), dependencies = FALSE ) ## R version 4.4.0 (2024-04-24 ucrt) ## Platform: x86_64-w64-mingw32/x64 ## Running under: Windows 11 x64 (build 26100) ## ## Locale: ## LC_COLLATE=Spanish_Spain.utf8 LC_CTYPE=Spanish_Spain.utf8 ## LC_MONETARY=Spanish_Spain.utf8 LC_NUMERIC=C ## LC_TIME=Spanish_Spain.utf8 ## ## Package version: ## biomaRt_2.60.1 data.table_1.15.4 dplyr_1.1.4 forcats_1.0.0 ## pROC_1.18.5 purrr_1.0.2 readr_2.1.5 ROCnGO_0.0.0.9000 ## ROCpAI_1.16.0 Seurat_5.0.3 stringr_1.5.1 tibble_3.2.1 ## tidyr_1.3.1 "],["referencias.html", "Referencias", " Referencias Advani, Rahul, Sara Luzzi, Emma Scott, Caroline Dalgliesh, Joachim Weischenfeldt, Jennifer Munkley, and David J. Elliot. 2023. “Epithelial Specific Splicing Regulator Proteins as Emerging Oncogenes in Aggressive Prostate Cancer.” Oncogene 42: 3161–68. Amezquita, Robert, Aaron Lun, Stephanie Hicks, Raphael Gottardo, and Alan O’Callaghan. 2024. “Orchestrating Single-Cell Analysis with Bioconductor.” In. Bioconductor. https://bioconductor.org/books/release/OSCA/. Barclay, Wendy W., Linara S. Axanova, Wenhong Chen, Lina Romero, Sophia L. Maund, Shay Soker, Cynthia J. Lees, and Scott D. Cramer. 2008. “Characterization of Adult Prostatic Progenitor/Stem Cells Exhibiting Self-Renewal and Multilineage Differentiation.” Stem Cells 26 (3): 600–610. Barrett, Tyson, Matt Dowle, Arun Srinivasan, Jan Gorecki, Michael Chirico, and Toby Hocking. 2024. Data.table: Extension of ‘Data.frame‘. https://r-datatable.com. Benelli, Roberto, Sara Stigliani, Simona Minghelli, Sebastiano Carlone, and Nicoletta Ferrari. 2013. “Impact of CXCL1 Overexpression on Growth and Invasion of Prostate Cancer Cell.” Prostate 73 (9): 941–51. Brennecke, Philip, Simon Anders, Jong Kyoung Kim, Aleksandra A. Kołodziejczyk, Xiuwei Zhang, Valentina Proserpio, Bianka Baying, et al. 2013. “Accounting for Technical Noise in Single-Cell RNA-Seq Experiments.” Nat Methods, 1093–95. Browne, A. J., A. Göbel, S. Thiele, L. C. Hofbauer, M. Rauner, and T. D. Rachner. 2016. “P38 MAPK Regulates the Wnt Inhibitor Dickkopf-1 in Osteotropic Prostate Cancer Cells.” Cell Death Dis. 7 (2): 2119. Bu, Huajie, Stefanie Bormann, Georg Schäfer, Wolfgang Horninger, Petra Massoner, Antje Neeb, Vinoth-Kumar Lakshmanan, et al. 2011. “The Anterior Gradient 2 (AGR2) Gene Is Overexpressed in Prostate Cancer and May Be Useful as a Urine Sediment Marker for Prostate Cancer Detection.” Prostate 71 (6): 575–87. Chang, Junkai, Weibo Xu, Guangchao Liu, Xinyi Du, and Xiaodong Li. 2017. “Downregulation of Rab23 in Prostate Cancer Inhibits Tumor Growth in Vitro and in Vivo.” Oncol. Res. 25 (2): 241–48. Conesa, Ana, Pedro Madrigal, Sonia Tarazona, David Gomez-Cabrero, Alejandra Cervera, Andrew McPherson, Michał Wojciech Szcześniak, et al. 2016. “A Survey of Best Practices for RNA-Seq Data Analysis.” Genome Biology 17 (13). Durinck, Steffen, and Wolfgang Huber. 2024. biomaRt: Interface to BioMart Databases (i.e. Ensembl). https://doi.org/10.18129/B9.bioc.biomaRt. Erho, Nicholas, Anamaria Crisan, Ismael A. Vergara, Anirban P. Mitra, Mercedeh Ghadessi, Christine Buerki, Eric J. Bergstralh, et al. 2013. “Discovery and Validation of a Prostate Cancer Genomic Classifier That Predicts Early Metastasis Following Radical Prostatectomy.” PLoS One 8 (6). Farha, Mark W., and Simpa S. Salami. 2022. “Biomarkers for Prostate Cancer Detection and Risk Stratification.” Ther Adv Urol. 14. Franco, Manuel, and Juana-María Vivo. 2021. “Evaluating the Performances of Biomarkers over a Restricted Domain of High Sensitivity.” Mathematics 9 (21): 2826. Garcia, Juan-Pedro, Manuel Franco, and Juana-María Vivo. 2024. ROCpAI: Receiver Operating Characteristic Partial Area Indexes for Evaluating Classifiers. Haberkorn, Uwe, Matthias Eder, Klaus Kopka, John W. Babich, and Michael Eisenhub. 2016. “New Strategies in Prostate Cancer: Prostate-Specific Membrane Antigen (PSMA) Ligands for Diagnosis and Therapy.” Clin Cancer Res. 22 (1): 9–15. Ilicic, Tomislav, Jong Kyoung Kim, Aleksandra A. Kolodziejczyk, Frederik Otzen Bagger, Davis James McCarthy, John C. Marioni, and Sarah A. Teichmann. 2016. “Classification of Low Quality Cells from Single-Cell RNA-Seq Data.” Genome Biology 17: 29. Jiang, Ning, Shimiao Zhu, Jing Chen, Yuanjie Niu, and Liqun Zhou. 2013. “A-Methylacyl-CoA Racemase (AMACR) and Prostate-Cancer Risk: A Meta-Analysis of 4,385 Participants.” PLoS One 8 (10). Jiang, Yulei, Charles E. Metz, and Robert M. Nishikawa. 1996. “A Receiver Operating Characteristic Partial Area Index for Highly Sensitive Diagnostic Tests.” Radiology 201 (3): 745–50. Klein, Eric A., Matthew R. Cooperber, Cristina Magi-Galluzzi, Jeffry P. Simko, Sara M. Falzarano, Tara Maddala, June M. Chan, et al. 2014. “A 17-Gene Assay to Predict Prostate Cancer Aggressiveness in the Context of Gleason Grade Heterogeneity, Tumor Multifocality, and Biopsy Undersampling.” Eur. Urol. 66 (3): 550–60. Ma, Hua, Andriy I. Bandos, and David Gur. 2015. “On the Use of Partial Area Under the ROC Curve for Comparison of Two Diagnostic Tests.” Biometrical Journal 57 (2): 304–20. Ma, Xiaoshi, Jinanand Guo, Kaisheng Liu, Lipeng Chen, Dale Liu, Shaowei Dong, Jinquan Xia, et al. 2020. “Identification of a Distinct Luminal Subgroup Diagnosing and Stratifying Early Stage Prostate Cancer by Tissue-Based Single-Cell RNA Sequencing.” Molecular Cancer 19: 147. McClish, Donna Katzman. 1989. “Analyzing a Portion of the ROC Curve.” Medical Decision Making 9 (3): 190–95. Müller, Kirill, and Hadley Wickham. 2023. Tibble: Simple Data Frames. https://tibble.tidyverse.org/. Robin, Xavier, Natacha Turck, Alexandre Hainard, Natalia Tiberti, Frédérique Lisacek, Jean-Charles Sanchez, and Markus Müller. 2023. pROC: Display and Analyze ROC Curves. https://xrobin.github.io/pROC/. Satija, Rahul. 2024. Seurat: Tools for Single Cell Genomics. https://satijalab.org/seurat. Seed, Robert I., Alberto J. Taurozzi, Daniel J. Wilcock, Giovanna Nappo, Holger H. H. Erb, Martin L. Read, Mark Gurney, et al. 2019. “The Putative Tumour Suppressor Protein Latexin Is Secreted by Prostate Luminal Cells and Is Downregulated in Malignancy.” Sci Rep. 9 (1): 5120. Sheehan, Beshara, Christina Guo, Antje Neeb, Alec Paschalis, Shahneen Sandhu, and Johann S. de Bono. 2022. “Prostate-Specific Membrane Antigen Biology in Lethal Prostate Cancer and Its Therapeutic Implications.” European Urology Focus 8 (5): 1157–68. Stuart, Tim, Andrew Butler, Paul Hoffman, Christoph Hafemeister, Efthymia Papalexi, William M. Mauck 3rd, Yuhan Hao, Marlon Stoeckius, Peter Smibert, and Rahul Satija. 2019. “Comprehensive Integration of Single-Cell Data.” Cell 177 (7): 1888–1902. Thompson, Maxwell, Jacques Lapoint, Yoon-La Choi, David E. Ong, John P. Higgins, James D. Brooks, and Jonathan R. Pollack. 2008. “Identification of Candidate Prostate Cancer Genes Through Comparative Expression-Profiling of Seminal Vesicle.” Prostate 68 (11): 1248–56. Ueda, Koji, Ayako Tatsuguchi, Naomi Saichi, Atsuhiko Toyama, Kenji Tamura, Mutsuo Furihata, Ryo Takata, et al. 2013. “Plasma Low-Molecular-Weight Proteome Profiling Identified Neuropeptide-y as a Prostate Cancer Biomarker Polypeptide.” J Proteome Res. 12 (10): 4497–4506. Vivo, Juana-María, Manuel Franco, and Donatella Vicari. 2018. “Rethinking an ROC Partial Area Index for Evaluating the Classification Performance at a High Specificity Range.” Advances in Data Analysis and Classification 12: 683–704. Wang, Zhanfeng, and Yan-Chin Ivan Chang. 2011. “Marker Selection via Maximizing the Partial Area Under the ROC Curve of Linear Risk Scores.” Biostatistics 12 (2): 369–85. Wasim, Sobia, Sang-Yong Lee, and Jaehong Kim. 2022. “Complexities of Prostate Cancer.” Int. J. Mol. Sci. 23 (22): 14257. Wickham, Hadley. 2023a. Forcats: Tools for Working with Categorical Variables (Factors). https://forcats.tidyverse.org/. ———. 2023b. Stringr: Simple, Consistent Wrappers for Common String Operations. https://stringr.tidyverse.org. Wickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org. Wickham, Hadley, and Lionel Henry. 2023. Purrr: Functional Programming Tools. https://purrr.tidyverse.org/. Wickham, Hadley, Jim Hester, and Jennifer Bryan. 2024. Readr: Read Rectangular Text Data. https://readr.tidyverse.org. Wickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2024. Tidyr: Tidy Messy Data. https://tidyr.tidyverse.org. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
