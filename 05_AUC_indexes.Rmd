---
title: "05_AUC_indexes"
author: "Pablo Navarro Carpio"
date: "2024-08-14"
output: html_document
---

# 1. Importar librerías y datos

```{r Importar librerías}
library(pROC)
library(purrr)
library(dplyr)
library(forcats)
library(tibble)
library(ROCpAI)
library(ROCnGO)
```

Para esta sección necesitaremos el conjunto de datos generado en la anterior sesión. El conjunto de datos contiene los niveles de diversos genes expresados en células luminales de próstata de pacientes con cancer.

```{r Importar datos}
roc_data <- readRDS("./rds_objects/04_filtered_tcga_data.rds")
```

# 2. AUCs

## 2.1. Introducción

En la literatura, 2 de las aproximaciones estadísticas más usadas para evaluar y comparar el rendimiento de una función o clasificador binario han sido las curvas $ROC$ (Característica Operativa del Receptor) y el área bajo dichas curvas ($AUC$).

El principal objetivo de un clasificador binario es discrimar instancias con una condición de interés de aquellas que no lo posean. Su precisión viene determianada por 2 métricas: su sensibilidad y su especificidad o la tasa verdaderos positivos ($TPR = Sensitivity$) y la tasa de falsos positivos ($FPR = 1 - Specificity$).

Cuando se trabaja con marcadores continuos, estos pueden ser dicotomizados en instancias positivas y negativas seleccionando una de las puntuaciones del marcador como un punto de corte, o umbral de decisión. Las curva $ROC$ representa los valores de $TPR$ y $FPR$ para cada uno de los umbrales de decisión de un marcador. Dado que estos puntos se calculan para todo un rango de umbrales, el $AUC$ actúa como una métrica global, mostrando los intercambios entre ambos parámetros de la curva, la ganancia o perdida de una métrica frente a otra.

## 2.2. Cálculo de AUCs para diagnóstico

Una vez se ha comprendido la teoría, podemos proceder a realizar los cálculos. Para ello utilizaremos el la función `pROC::auc`, que calcula dicho parámetro utilizando una la variable para hacer la predicción (`predictor`) y una variable que contenga la respuesta a dicha predicción (`response`).

Dado que en nuestro caso, buscaremos repetir el proceso para cada una de las variables utilizaremos la función `purrr::map_dbl`.

```{r Cálculo de AUCs para diagnóstico}
diagnostic_dataset <- roc_data %>% select(
    -c("sample", "gleason_score", "malignancy", "disease", "prognostic")
    )

auc_diagnostic <- map_dbl(
    diagnostic_dataset,
    auc,
    response = roc_data$disease,
    direction = "<",
    quiet = TRUE,
    .progress = TRUE
)
```

La función iterará sobre las columnas de los predictores y aplicará la función sobre cada uno de ellos. Como en este caso, buscaremos comprobar su validez como marcadores de diagnóstico, seleccionaremos la variable `disease` como la variable de respuesta.

## 2.3. Cálculo de AUCs para pronóstico

De forma similar a la anterior sección, podemos calcular que marcadores será mejores predictores con respecto a establecer un pronóstico para la enfermedad.

Esta sección requerirá de un filtrado previo, puesto que nuestro conjunto de datos contiene entradas de tanto tejidos sanos como enfermos, y para pronóstico, solo nos interesarán aquellos con la enfermedad. Para ello filtraremos los casos en los que se presenta la enfermedad y como estabamos trabajando con factores eliminaremos aquellos que no se utilizan (`Normal`).

```{r Filtrado de casos enfermos}
disease <- roc_data %>% filter(disease == 1)
disease[["prognostic"]] <- fct_drop(disease[["prognostic"]])
```

Una vez realizado el filtrado, podemos realizar el mismo procedimiento.

```{r Cálculo de AUCs para pronóstico}
prognostic_dataset <- disease %>% select(
    -c("sample", "gleason_score", "malignancy", "disease", "prognostic")
    )

auc_prognostic <- map_dbl(
    prognostic_dataset,
    auc,
    response = disease$prognostic,
    direction = "<",
    quiet = TRUE,
    .progress = TRUE
)
```
# 3. pAUC

## 3.1. Introducción

En ciertos contextos el estudio de la curva ROC en su totalidad no es de interés. En aplicaciones médicas y en otros campos, suelen seleccionarse ciertos rangos de la curva debido al interés por unos valores concretos de $TPR$ o $FPR$.

Por ejemplo en un contexto de diagnóstico, un marcador con un bajo $FPR$ (alta especifidad) es relevante a la hora de confirmar la presencia de una condición ("rule in"), dado que es muy improbable que se de un falso positivo. Mientras que un marcador con un alto $TPR$ (alta sensibilidad) es relevante para descartar la presencia de una condición ("rule out"), dado que es muy improbable que se de un falso negativo.

En estas situaciones el area parcial de la curva ROC ($pAUC$) atrae mucha más atención, ya que esta métrica sintetiza la información en la región de interés en lugar de en toda la curva.

## 3.2. Cálculo de pAUCs en regiones de alta especificidad

Explicada la importancia de trabajar en regiones concretas, podemos transladar la explicación a nuestro caso.

Un [diagnóstico temprano del cáncer de próstata](https://academic.oup.com/biostatistics/article/12/2/369/279985) es de gran importancia. En esta situación el pronóstico de un paciente puede mejorar en gran medida. 

Sin embargo, el tratamiento para estas enfermedades es agresivo y debe considerarse. En este caso diagnósticar a un paciente con la enfermedad cuando no la tiene, puede ser un caso muy grave. Dada la situación es conveniente reducir estos casos, es decir el número de falsos positivos, por lo que requeriremos de una alta especificidad.

Para trabajar en condiciones de alta especificidad, seleccionaremos arbitrariamente rangos de $TPR$ contenidos en un intervalo de $(0.9,1)$. Para realizar estos cálculos utilizaremos de nuevo la función `pROC::auc` esta vez indicando que se limite a la especificidad (`partial.auc.focus = "spec"`) y sobre un rango concreto (`partial.auc = c(0.9, 1)`).

```{r Cálculo de pAUC en especificidad para diagnóstico}
pauc_sp_diagnostic <- map_dbl(
    diagnostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "spec",
    response = roc_data$disease,
    direction = "<",
    quiet = T,
    .progress = T
)
```

De forma similar, el pronóstico determinado para un paciente es relevante a la hora de seleccionar un tratamiento más o menos agresivo. Podríamos pensar de forma similar al escenario del caso de diagnóstico, un falso positivo puede tener consecuencias graves. Por ello consideraremos también condiciones de alta especificidad para la determinación de un pronóstico.

```{r Cálculo de pAUC en especificidad para pronóstico}
pauc_sp_prognostic <- map_dbl(
    prognostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "spec",
    response = disease$prognostic,
    direction = "<",
    quiet = T,
    .progress = T
)
```


## 3.3. Cálculo de pAUCs en regiones de alta sensibilidad

De forma similar al caso anterior podemos trasladar el caso de estudio a condiciones de alta sensibilidad. Escenarios donde se require una alta sensibilidad vienen dados normalmente por enfermedades que son fatales si no es tratan. Cometer un falso negativo puede implicar la muerte del paciente.

Hacer un mal pronóstico del paciente puede suponer graves consecuencias, por lo que a la hora de realizarlo puede ser importante considerar una alta sensibilidad. De modo que para calcular los índices, simplemente realizaremos el procedimiento anterior indicando que utilizaremos la sensibilidad (`partial.auc.focus = "sens"`).

```{r Cálculo de pAUC en sensibilidad para pronóstico}
pauc_sn_prognostic <- map_dbl(
    prognostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "sens",
    response = disease$prognostic,
    direction = "<",
    quiet = T,
    .progress = T
)
```
Finalmente y aunque quizá menos interesante desde el punto de vista clínico, pero también podríamos considerar relevante un contexto de alta sensibilidad para el diagnóstico de la enfermedad. Como hemos explicado antes, un diagnóstico temprano puede ser relevante en relación a evitar la muerte del paciente, por ello también podría llegar a considerarse este índice.

```{r Cálculo de pAUC en sensibilidad para diagnóstico}
pauc_sn_diagnostic <- map_dbl(
    diagnostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "sens",
    response = roc_data$disease,
    direction = "<",
    quiet = T,
    .progress = T
)
```
# 4. Índices derivados de pAUC

## 4.1. Problemas del pAUC

Aunque el $pAUC$ puede ser útil para trabajar en regiones de ínteres en la curva $ROC$ no está libre de fallas.

Este índice ha sido cuestionado por la falta de interpretabilidad, ya que algunos marcadores que puedan presentar altos valores para $AUC$ e incluso que rinden bien en las zonas seleccionadas, presentan valores de $pAUC$ muy ceracnos a 0.

Podemos comprobarlo con, por ejemplo, los 10 valores más altos de $AUC$ en marcadores de diagnóstico trabajando con alta especificidad.

```{r Comparación entre AUCs y pAUCs}
enframe(auc_diagnostic) %>%
    arrange(desc(value)) %>%
    left_join(
        enframe(pauc_sp_diagnostic),
        join_by(name == name)
    ) %>%
    dplyr::rename(
        auc = value.x,
        pauc = value.y
    ) %>%
    .[0:10,]
```

Como podemos observar, los valores obtenidos para $pAUC$ no superan el $0.5$; valor límite en el $AUC$ con el que consideraríamos que un clasificador rinde igual que un clasificador completamente aleatorio.

Además de por su interpretabilidad, la métrica presenta problemas cuando dos marcadores presentan valores iguales para el $pAUC$ pero sus curvas $ROC$ se cruzan, [imposibilitando el decidir cual de los 2 clasificadores rinde mejor](https://onlinelibrary.wiley.com/doi/full/10.1002/bimj.201400023). Este fenómeno se comprobará más adelante.

Para lidiar con estos problemas se han desarrollado diferentes transformaciones en los diversos índices, tanto en especificidad como en sensibilidad.

## 4.2. Índices para la especificidad

### 4.2.1. SpAUC

Una de las primeras transformaciones [propuestas por McClish](https://journals.sagepub.com/doi/10.1177/0272989X8900900307), es el área parcial bajo curva estandarizada ($SpAUC$). 

Esta transformación trabaja con sobre un rango concreto de especificidad $(FPR_1, FPR_2)$, donde los límites superior e inferior para el $pAUC$ se escalan a los valores en el intervalo $(0.5, 1)$, haciendo que la métrica sea más interpretable. A pesar de ello, la métrica todavía presenta algunas desventajas.

El límite superior para el área que engloba el $pAUC$, esta definida por el rectángulo formado por los puntos: $(FPR_1, 0), (FPR_2, 0), (FPR_1, 1)$ y $(FPR_2, 1)$. Mientras que el límite inferior está definido por el trapecio con puntos: $(FPR_1, 0), (FPR_2, 0), (FPR_1, FPR_1)$ y $(FPR_2, FPR_2)$. Este será el trapecio que coincide con la diagonal de la curva. Si calculamos las áreas de los límites, el área $(A)$ que puede tomar el $pAUC$ está definida de la siguiente forma:

$$ 
\dfrac{1}{2}(FPR_2 - FPR_1)(FPR_2 + FPR_1) \le A \le FPR_2 - FPR_1
$$
Realizando la siguiente tranformación:

$$
\dfrac{1}{2}\left[1 + \dfrac{A - \text{min}}{\text{max} - \text{min}} \right]
$$
El índice toma un valor de $1$ cuando $A = \text{max}$ y un valor de $0.5$ cuando $A = \text{min}$, permitiendo ver el $pAUC$ de forma escalada al área total.

El problema que presenta la métrica, es que asume el mismo límite inferior para todas las curvas. En la práctica es común trabajar con curvas que atraviesen la diagonal, por lo que el límite inferior no está bien definido. Además, aunque resuelve el problema de facilitar la interpretación, no solventa el problema de 2 curvas con igual $pAUC$ que se cruzan.

Conociendo sus ventajas y desventajas, calcularemos el índice para contrastarlo con otros métodos. Para ello utilizaremos también la función `pROC::auc` indicando el argumento `partial.auc.correct = TRUE` para que aplique la corrección descrita por McClish. Además indicaremos `allow.invalid.partial.auc.correct = FALSE`, de esta forma la función no calculará el índice (aunque sea posible) si la curva está descrita por debajo del area mínima puesto que el límite inferior no está bien definido; en su lugar devolverá un `NA`.

```{r Cálculo de SpAUC para diagnóstico, warning=FALSE}
spauc_sp_diagnostic <- map_dbl(
    diagnostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "spec",
    partial.auc.correct = TRUE,
    allow.invalid.partial.auc.correct = FALSE,
    response = roc_data$disease,
    direction = "<",
    quiet = TRUE,
    .progress = TRUE
)
```

```{r Cálculo de SpAUC para pronóstico, warning=FALSE}
spauc_sp_prognostic<- map_dbl(
    prognostic_dataset,
    auc,
    partial.auc = c(0.9, 1),
    partial.auc.focus = "spec",
    partial.auc.correct = TRUE,
    allow.invalid.partial.auc.correct = FALSE,
    response = disease$prognostic,
    direction = "<",
    quiet = TRUE,
    .progress = TRUE
)
```

### 4.2.2. TpAUC

Para solventar los problemas que el $SpAUC$ todavía presenta, [Vivo et al. han propuesto](https://link.springer.com/article/10.1007/s11634-017-0295-9) un índice alternativo para rangos especificidades concretos, el "tighter partial area index" $TpAUC$. Este nuevo índice, encuentra nuevos límites todavía más ajustados y teniendo en cuenta la forma que puede adoptar la curva $ROC$, es decir, siendo compatible con curvas que pasan por debajo de la diagonal o son inadecuadas.

Los límites iniciales propuestos por este índice parten de los establecidos por el $SpAUC$:

$$
\dfrac{1}{2}(FPR_2 - FPR_1)(FPR_2 + FPR_1) \le A \le FPR_2 - FPR_1
$$

Sin embargo, Vivo et al. proponen que estos límites se pueden ajustar a las regiones del area parcial donde esté definida la curva. Es decir, ajustandose a los puntos de la curva presentes en la región de interes, donde $TPR_i = TPR(FPR_i)$ para $i = 1,2$. De esta forma los límites se ajustan a:

$$
TPR_1(FPR_2 - FPR_1) \le A \le TPR_2(FPR_2-FPR_1)
$$

Este índice inferior se ajusta incluso cuando las curvas son inadecuadas en el límite inferior. De esta forma, cuando las curvas son adecuadas y no presentan ganchos, la siguiente expresión puede utilizarse:

$$
\text{max}\left\{TPR_1(FPR_2 - FPR_1), \dfrac{1}{2}(FPR_2 - FPR_1)(FPR_2 + FPR_1)\right\} \le A \le TPR_2(FPR_2-FPR_1)
$$

Finalmente, se debe considerar que las curvas $ROC$ normalmente son concavas, salvando la presencia de irregularidades (e.g. ganchos). Una curva $ROC$ concava, presenta un ratio de probabilidad positivo ($PLR(t) = ROC(t)/t$) decreciente. De esta forma el $PLR$ alcaza valores mínimos en el extremo superior de la curva.

Trasladado a este caso, si se puede asegurar que la curva se mantiene concava en la región de interés, es decir $PLR$ alcanza su mínimo valor en $FPR_2$ un límite inferior más ajustado se puede determinar, correspondiéndose al trapecio con puntos: $(FPR_1,0), (FPR_2, 0), (FPR_1, TPR_2)$ y $(FPR_2, TPR_2)$. Desarrollando esta área obtenemos:

$$
\dfrac{1}{2}(TPR_1+TPR_2)(FPR_2-FPR_1) \le A \le TPR_2(FPR_2-FPR_1)
$$

Conociendo los límites inferior y superior, y usándolos según las condiciones descritas, aplicando la transformación descrita por McClish para encapsular los valores entre $(0.5,1)$:

$$
\dfrac{1}{2}\left[1 + \dfrac{A - \text{min}}{\text{max} - \text{min}} \right]
$$

Se obtiene finalmente el $TpAUC$.

De forma similar, procederemos a calcularlo para contrastarlo con las demás métricas. El algoritmo para el cálculo de este índice está implementado en el paquete `ROCpAI` de [Bioconductor](https://www.bioconductor.org/packages/release/bioc/html/ROCpAI.html) con la función `tpAUC`. El paquete además incluye funciones para el cálculo de sus estabilidades, aunque para este caso nos bastará con la función principal.

La función utiliza como entrada un dataset donde la primera columna se corresponda con la respuesta y las siguientes los predictores.

```{r Cálculo de TpAUC para diagnóstico}
tpauc_sp_diagnostic_assay <- tpAUC(
    dataset = diagnostic_dataset %>% mutate(
        disease = roc_data$disease,
        .before = 1
    ),
    low.value = 0,
    up.value = 0.1,
    plot = FALSE
)
```

```{r Cálculo de TpAUC para pronóstico}
tpauc_sp_prognostic_assay <- tpAUC(
    dataset = prognostic_dataset %>% mutate(
        prognostic = disease$prognostic,
        .before = 1
    ),
    low.value = 0,
    up.value = 0.1,
    plot = FALSE
)
```

Dado que la salida de la función es un objeto con diversas métricas, utilizaremos la función `assay` para extraer los $SpAUC$ almacenados en en `St_pAUC`. Finalmente nombraremos cada uno de los valores con su respectivo identificador.

```{r Transformación en vector}
tpauc_sp_diagnostic <- as.numeric(assay(tpauc_sp_diagnostic_assay)$St_pAUC)
tpauc_sp_prognostic <- as.numeric(assay(tpauc_sp_prognostic_assay)$St_pAUC)

names(tpauc_sp_diagnostic) <- colnames(diagnostic_dataset)
names(tpauc_sp_prognostic) <- colnames(prognostic_dataset)
```

## 4.3. Índices para la sensibilidad

### 4.3.1. NpAUC

Uno de los primeros índices enfocados a trabajar en regiones de alta sensibilidad, es el [propuesto por Jiang et al.](https://sci-hub.se/https://doi.org/10.1148/radiology.201.3.8939225), el índice del area parcial normalizado ($NpAUC$). Este índices es conceptualmente similar a $SpAUC$. Teniendo en cuenta que para este caso $TPR_2 = 1$ y $TPR_1 = TPR_0$ y $TPR_1 < TPR_2$ se definen los límites superiores e inferiores, dados por: 

+ El rectángulo de puntos $(1,1), (1, TPR_0), (0, 1)$ y $(0, TPR_0)$, es decir de longitud $1$ y altura dada por la banda $1 - TPR_0$.
+ El triángulo de puntos $(TPR_0, TPR_0), (1, TPR_0)$ y $(1,1)$.

Que de forma desarrollada, quedaría de la siguiente forma:

$$
\dfrac{1}{2}(1 - TPR_0)^2 \le A \le 1 - TPR_0
$$

A continuación, para llevar a cabo la normalización simplemente se divide cada término entre $1-TPR_0$ que se corresponde, como hemos explicado antes, con el área del rectángulo superior al $pAUC$.

$$
\dfrac{1}{2}(1-TPR_0) \le \dfrac{A}{1 - TPR_0} \le 1
$$

De esta forma, la métrica propuesta sería la siguiente:

$$
A' = \dfrac{A}{1 - TPR_0}
$$

Esta transformación permite que la métrica se interprete como el valor promedio de la especificidad para todos los valores de sensibilidad por encima de $TPR_0$.

A pesar de su utilidad a la hora de producir valores más interpretables y ser aplicable con algunas curvas inapropiadas, sigue presentando algunas desventajas. En primer lugar, el índices puede dar en ocasiones valores inferiores a $0.5$ y en segundo lugar, no es capaz de comparar de forma adecuada diversos clasificadores que puedan mostrar diferente forma en sus curvas $ROC$ y que tengan el mismo $pAUC$.

De forma similar a los otros índices procederemos a calcularlo para más tarde contrastarlo con el resto. Dado que el $NpAUC$ no se encuntra disponible en ningún paquete conocido, para facilitar su uso este índice ha sido incluido en un paquete propio, `ROCnGO`. 

El paquete cuenta con la función `ROCnGO::np_auc`, que nos permite calcular el índice con un procedimiento similar a los casos anteriores.

```{r Cálculo de NpAUC para diagnóstico, warning=FALSE}
npauc_sn_diagnostic <- map_dbl(
    diagnostic_dataset,
    \(gene) {
        np_auc(
            predictor = gene,
            response = roc_data$disease,
            lower_tpr = 0.9
        )
    },
    .progress = TRUE
)
```

```{r Cálculo de NpAUC para pronóstico, warning=FALSE}
npauc_sn_prognostic <- map_dbl(
    prognostic_dataset,
    \(gene) {
        np_auc(
            predictor = gene,
            response = disease$prognostic,
            lower_tpr = 0.9
        )
    },
    .progress = TRUE
)
```

### 4.3.2. FpAUC

De forma similar al $TpAUC$ con respecto al $SpAUC$, en casos de especificidad, [Vivo et al.](https://www.mdpi.com/2227-7390/9/21/2826) propusieron un índice que pudiera solventar las desventajas del $NpAUC$. Este índice, denominado "fitted partial area index" ($FpAUC$), además de conservar las ventajas propuestas por el anterior, solventa los problemas que presentaba.

De esta forma el $FpAUC$ es capaz de:

1. Ser interpretable como métrica de diagnóstico. Esto incluye ser igual a $AUC$ cuando $TPR_0 = 0$.
1. Aplicarse a cualquier forma de la curva $ROC$, incluyendo las inadecuadas.
1. Distinguir dos clasificadores con $pAUC$ iguales y que sus curvas $ROC$ se crucen.

Para calcular el $FpAUC$ en primer lugar, se deben definir nuevos límites para el $pAUC$ en condiciones de alta sensiblidad. En primer lugar, los límites iniciales son similares a los definidos en $NpAUC$, es decir:

$$
\dfrac{1}{2}(1 - TPR_0)^2 \le A \le 1 - TPR_0
$$

En primer lugar, un nuevo límite superior puede ser definido. Dado que una curva $ROC$ es una representación de las parejas de $TPR$ y $FPR$, de esta este límite puede limitarse a la región donde esté definidad la curva. Es decir, al rectángulo de puntos $(FPR_0, TPR_0), (FPR_0, 1), (1, TPR_0)$ y $(1,1)$, donde $FPR_0$ es el $FPR$ para el punto de la curva con $TPR_0$. De esta forma se obtiene:

$$
\dfrac{1}{2}(1 - TPR_0)^2 \le A \le (1-FPR_0)(1 - TPR_0)
$$

Como se ha explicado anteriormente, durante la sección del $TpAUC$, por definción las curvas $ROC$ son funciones monótonas no decrecientes. Esto no asegura, sin embargo, que sean concavas ya que en algunas ocasiones pueden pasar por debajo de la diagonal y mostrar rendimientos peores al de un predictor aleatorio.

La concavidad de la curva puede ser determinada por métricas como el ratio de probabilidad negativa ($NLR$). El $NLR$ se puede expresar matemáticamente de la siguiente forma $NLR = (1 - ROC(t))/(1 - t)$ para cada punto de la curva. Gráficamente, el $NLR$ representa la pendiente de la línea recta que pasa por un putno de la curva $ROC$ y el punto $(1,1)$. De esta forma, una curva concava presentará un $NLR$ decreciente.

De esta forma, si $NLR(t) \le NLR_0$ donde $NLR_0 = NLR(FPR_0)$ para $t \ge FPR_0$ o en otras palabras, si se asegura la concavidad en la región de alta sensibilidad, podemos definir un límite inferior más ajustado que viene dado por el triángulo de puntos $(FPR_0, TPR_0), (1, TPR_0)$ y $(1,1)$. De esta forma, podríamos ajustar los límites a:

$$
\dfrac{1}{2}(1 - FPR_0)(1 - TPR_0) \le A \le (1-FPR_0)(1 - TPR_0)
$$

Finalmente se debe considerar la posibilidad de que puedan aparecer ganchos en el extremo superior derecho de la región. En estas situaciones, incluso el límite inferior cuando no trabajamos con una curva $ROC$ concava, no se ajusta. De esta forma, se define que si existe $t \ge FPR_0$ que cumpla $NLR(t) > \text{max}\ \{1, NLR_0\}$, no podemos encontrar un límite inferior que se ajuste de forma que:

$$
0 \le A \le (1-FPR_0)(1 - TPR_0)
$$
Conociendo y considerando todas los casos posibles simplemente, aplicando la transformación descrita por McClish para que el índice quede contenido en un rango de $(0.5, 1)$

$$
\dfrac{1}{2}\left[1 + \dfrac{A - \text{min}}{\text{max} - \text{min}} \right]
$$

se obtiene el índice $FpAUC$.

De forma similar a los casos anteriores, calcularemos el índice para contrastarlo con el resto. Al igual que el $NpAUC$, el $FpAUC$ no se encuentra actualmente en ningún paquete conocido, por lo que también se ha incluido una función que permite calcularlo en el paquete `ROCnGO`.

Para calcular el índice para los predictores, se utilizará la función `ROCnGO:fp_auc`:

```{r Cálculo de FpAUC para diagnóstico, warning=FALSE}
fpauc_sn_diagnostic <- map_dbl(
    diagnostic_dataset,
    \(gene) {
        fp_auc(
            predictor = gene,
            response = roc_data$disease,
            lower_tpr = 0.9
        )
    },
    .progress = TRUE
)
```

```{r Cálculo de FpAUC para pronóstico, warning=FALSE}
fpauc_sn_prognostic <- map_dbl(
    prognostic_dataset,
    \(gene) {
        fp_auc(
            predictor = gene,
            response = disease$prognostic,
            lower_tpr = 0.9
        )
    },
    .progress = TRUE
)
```
# 5. Evaluación de índices

Hasta ahora se han calculado todos los índices para condiciones de alta sensibilidad y especificidad, enfocados a encontrar marcadores de diagnóstico así como de pronóstico. Sin embargo, como se ha ido explicando, cada índice presenta una serie de ventajas y desventajas.

De esta forma, para poder evaluar cual de los siguientes índices presenta un mejor rendimiento a la hora de identificar un marcador para estas condiones, necesitaremos comparar sus resultados.

## 5.1. Agrupar por condiciones

Para poder realizar comparaciones, deberemos agrupar las puntuaciones de los índices en las distintas condiciones.

```{r Índices de sensiblidad para diagnóstico}
indexes_sn_diagnostic <- tibble(
    identifier = names(auc_diagnostic),
    auc = auc_diagnostic,
    pauc = pauc_sn_diagnostic,
    npauc = npauc_sn_diagnostic,
    fpauc = fpauc_sn_diagnostic
)
```

```{r Índices de sensiblidad para pronóstico}
indexes_sn_pronostic <- tibble(
    identifier = names(auc_prognostic),
    auc = auc_prognostic,
    pauc = pauc_sn_prognostic,
    npauc = npauc_sn_prognostic,
    fpauc = fpauc_sn_prognostic
)
```

```{r Índices de especificidad para diagnóstico}
indexes_sp_diagnostic <- tibble(
    identifier = names(auc_diagnostic),
    auc = auc_diagnostic,
    pauc = pauc_sp_diagnostic,
    spauc = spauc_sp_diagnostic,
    tpauc = tpauc_sp_diagnostic
)
```

```{r Índices de especificidad para pronóstico}
indexes_sp_pronostic <- tibble(
    identifier = names(auc_prognostic),
    auc = auc_prognostic,
    pauc = pauc_sp_prognostic,
    npauc = npauc_sn_prognostic,
    fpauc = fpauc_sn_prognostic
)
```



